import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const o=JSON.parse('{"title":"@ObservedObject：订阅外部对象的更新","description":"","frontmatter":{},"headers":[],"relativePath":"thinking/4.4_@ObservedObject：订阅外部对象的更新.md","filePath":"thinking/4.4_@ObservedObject：订阅外部对象的更新.md"}'),t={name:"thinking/4.4_@ObservedObject：订阅外部对象的更新.md"};function l(p,s,h,k,r,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="observedobject-订阅外部对象的更新" tabindex="-1">@ObservedObject：订阅外部对象的更新 <a class="header-anchor" href="#observedobject-订阅外部对象的更新" aria-label="Permalink to &quot;@ObservedObject：订阅外部对象的更新&quot;">​</a></h1><h2 id="深入理解-observedobject" tabindex="-1">深入理解 @ObservedObject <a class="header-anchor" href="#深入理解-observedobject" aria-label="Permalink to &quot;深入理解 @ObservedObject&quot;">​</a></h2><p><code>@ObservedObject</code> 是 SwiftUI 中一个强大的属性包装器。它允许你订阅外部引用类型对象的更新。当这些对象发布更改时，SwiftUI 会自动重新渲染依赖它们的视图。这对于管理复杂的数据模型至关重要。 🚀</p><h2 id="observedobject-的核心机制" tabindex="-1">@ObservedObject 的核心机制 <a class="header-anchor" href="#observedobject-的核心机制" aria-label="Permalink to &quot;@ObservedObject 的核心机制&quot;">​</a></h2><p>当你使用 <code>@ObservedObject</code> 声明一个属性时，你告诉 SwiftUI 密切关注这个对象。这个对象必须遵循 <code>ObservableObject</code> 协议。同时，它的属性需要使用 <code>@Published</code> 属性包装器。这样，任何对 <code>@Published</code> 属性的更改都会自动通知 SwiftUI。</p><ul><li><strong>遵循协议</strong>: 你的数据模型类必须遵循 <code>ObservableObject</code>。</li><li><strong>发布更改</strong>: 模型中的可观察属性需要用 <code>@Published</code> 标记。</li><li><strong>视图更新</strong>: 当 <code>@Published</code> 属性改变时，使用 <code>@ObservedObject</code> 的视图会自动刷新。</li></ul><p>例如，想象你有一个用户资料模型。当用户的名字或头像更新时，所有显示这些信息的视图都会立即反映这些变化。这极大地简化了UI同步的复杂性。</p><h2 id="使用场景与优势" tabindex="-1">使用场景与优势 <a class="header-anchor" href="#使用场景与优势" aria-label="Permalink to &quot;使用场景与优势&quot;">​</a></h2><p><code>@ObservedObject</code> 非常适合管理那些在多个视图之间共享，并且其生命周期由外部控制的数据。它不像 <code>@StateObject</code> 那样拥有对象的生命周期。这意味着，如果你的视图被销毁并重新创建，<code>@ObservedObject</code> 引用的对象不会被重新初始化。</p><ul><li><strong>外部生命周期</strong>: 对象由外部创建和管理。</li><li><strong>数据共享</strong>: 多个视图可以观察同一个对象。</li><li><strong>性能优化</strong>: SwiftUI 智能地只更新受影响的视图部分。</li></ul><p>例如，在一个大型应用程序中，你可能有一个全局的用户会话管理器。这个管理器在整个应用生命周期中只存在一个实例。通过 <code>@ObservedObject</code>，你可以让不同的视图订阅这个会话管理器的状态变化，例如登录状态或用户权限。</p><h2 id="与其他属性包装器的区别" tabindex="-1">与其他属性包装器的区别 <a class="header-anchor" href="#与其他属性包装器的区别" aria-label="Permalink to &quot;与其他属性包装器的区别&quot;">​</a></h2><p>理解 <code>@ObservedObject</code> 与 <code>@StateObject</code> 的区别至关重要。 <code>@StateObject</code> 负责创建和管理引用类型对象的生命周期。而 <code>@ObservedObject</code> 仅仅是订阅一个已经存在的对象。</p><ol><li><strong>生命周期管理</strong>: <ul><li><code>@StateObject</code>：视图拥有并管理对象的生命周期。</li><li><code>@ObservedObject</code>：视图不拥有对象，只是观察它。</li></ul></li><li><strong>创建时机</strong>: <ul><li><code>@StateObject</code>：在视图首次初始化时创建对象。</li><li><code>@ObservedObject</code>：引用一个外部已存在的对象。</li></ul></li></ol><p>选择正确的属性包装器可以显著提升你的应用性能和可维护性。例如，如果你在一个子视图中需要一个父视图传递过来的数据模型，并且这个模型在父视图中已经通过 <code>@StateObject</code> 创建，那么子视图就应该使用 <code>@ObservedObject</code> 来观察它。 🎯</p><h2 id="实际应用示例" tabindex="-1">实际应用示例 <a class="header-anchor" href="#实际应用示例" aria-label="Permalink to &quot;实际应用示例&quot;">​</a></h2><p>假设你正在构建一个任务管理应用。你有一个 <code>TaskManager</code> 类，它负责管理所有任务。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TaskManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ObservableObject </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @Published</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tasks: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> task: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        tasks.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在你的视图中，你可以这样使用它：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TaskListView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @ObservedObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> taskManager: TaskManager</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        VStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(taskManager.tasks, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: \\.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { task </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Add Task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                taskManager.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New Task </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(taskManager.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tasks</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>当你从外部传入一个 <code>TaskManager</code> 实例给 <code>TaskListView</code> 时，<code>TaskListView</code> 就会自动响应 <code>tasks</code> 数组的变化。这使得数据流清晰且易于管理。 🌟 这种模式在大型项目中非常常见，因为它促进了模块化和解耦。</p>`,21)]))}const b=i(t,[["render",l]]);export{o as __pageData,b as default};
