import{_ as s,c as e,o as a,ag as t}from"./chunks/framework.ymCRTBvy.js";const o=JSON.parse('{"title":"16.2_遵循系统协议（如UITextFieldDelegate）","description":"","frontmatter":{},"headers":[],"relativePath":"uikit/basics/16.2_遵循系统协议（如UITextFieldDelegate）.md","filePath":"uikit/basics/16.2_遵循系统协议（如UITextFieldDelegate）.md"}'),l={name:"uikit/basics/16.2_遵循系统协议（如UITextFieldDelegate）.md"};function n(h,i,p,d,k,r){return a(),e("div",null,i[0]||(i[0]=[t(`<h1 id="_16-2-遵循系统协议-如uitextfielddelegate" tabindex="-1">16.2_遵循系统协议（如UITextFieldDelegate） <a class="header-anchor" href="#_16-2-遵循系统协议-如uitextfielddelegate" aria-label="Permalink to &quot;16.2_遵循系统协议（如UITextFieldDelegate）&quot;">​</a></h1><h2 id="深入理解系统协议" tabindex="-1">深入理解系统协议 <a class="header-anchor" href="#深入理解系统协议" aria-label="Permalink to &quot;深入理解系统协议&quot;">​</a></h2><p>在iOS开发中，系统协议扮演着至关重要的角色，它们是Apple为我们提供的强大工具，用于实现不同对象间的通信和协作。想象一下，你正在构建一个用户界面，其中包含一个文本输入框（<code>UITextField</code>）。你希望在用户输入文本时，能够实时地获取输入内容，或者在用户点击键盘上的“完成”按钮时执行特定操作。这就是系统协议大显身手的地方！ 🚀</p><h2 id="为什么需要遵循系统协议" tabindex="-1">为什么需要遵循系统协议？ <a class="header-anchor" href="#为什么需要遵循系统协议" aria-label="Permalink to &quot;为什么需要遵循系统协议？&quot;">​</a></h2><p>遵循系统协议，比如<code>UITextFieldDelegate</code>，意味着你的某个类将承诺实现该协议中定义的一系列方法。这些方法通常被称为“代理方法”或“回调方法”。当<code>UITextField</code>发生特定事件时，它会“询问”它的代理对象（也就是你遵循协议的那个类）是否需要处理这些事件。这是一种非常灵活且解耦的设计模式，让你的代码更易于维护和扩展。</p><h2 id="如何遵循uitextfielddelegate协议" tabindex="-1">如何遵循<code>UITextFieldDelegate</code>协议 <a class="header-anchor" href="#如何遵循uitextfielddelegate协议" aria-label="Permalink to &quot;如何遵循\`UITextFieldDelegate\`协议&quot;">​</a></h2><p>要让你的视图控制器（例如<code>ViewController</code>）成为<code>UITextField</code>的代理，你需要做两件事：</p><ol><li><p><strong>声明遵循协议</strong>：在你的类定义中，使用冒号 <code>:</code> 并在后面加上协议名称。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UITextFieldDelegate </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这就像你向系统宣告：“嘿，我准备好处理<code>UITextField</code>的事件了！”</p></li><li><p><strong>设置代理</strong>：在你的<code>UITextField</code>实例创建后，将其<code>delegate</code>属性设置为你的视图控制器。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myTextField </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UITextField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myTextField.delegate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // self 指的是当前的 ViewController 实例</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这一步至关重要，它告诉<code>UITextField</code>：“当有事情发生时，请通知我！” 📢</p></li></ol><h2 id="实现uitextfielddelegate的常用方法" tabindex="-1">实现<code>UITextFieldDelegate</code>的常用方法 <a class="header-anchor" href="#实现uitextfielddelegate的常用方法" aria-label="Permalink to &quot;实现\`UITextFieldDelegate\`的常用方法&quot;">​</a></h2><p><code>UITextFieldDelegate</code>协议提供了许多有用的方法，让你能够精细地控制文本输入框的行为。以下是一些你可能会经常使用的：</p><ul><li><code>textFieldShouldBeginEditing(_:)</code>：在文本框即将开始编辑时调用。你可以返回<code>true</code>允许编辑，或<code>false</code>阻止编辑。</li><li><code>textFieldDidBeginEditing(_:)</code>：文本框已经开始编辑时调用。</li><li><code>textFieldShouldReturn(_:)</code>：当用户点击键盘上的“Return”键时调用。你可以在这里处理键盘的收起逻辑。</li><li><code>textField(_:shouldChangeCharactersIn:replacementString:)</code>：在文本框内容即将改变时调用。这是一个非常强大的方法，你可以用它来限制输入字符、格式化文本等。例如，你可以只允许数字输入。</li><li><code>textFieldDidEndEditing(_:)</code>：文本框结束编辑时调用。</li></ul><h2 id="实践-限制文本输入长度" tabindex="-1">实践：限制文本输入长度 <a class="header-anchor" href="#实践-限制文本输入长度" aria-label="Permalink to &quot;实践：限制文本输入长度&quot;">​</a></h2><p>让我们通过一个具体的例子来感受<code>UITextFieldDelegate</code>的魅力。假设你有一个文本框，要求用户输入的字符数不能超过10个。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> textField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textField: UITextField, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shouldChangeCharactersIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range: NSRange, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replacementString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textField.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    guard</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stringRange </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(range, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: currentText) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> updatedText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentText.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">replacingCharacters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: stringRange, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: string)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> updatedText.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 限制字符数不超过10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这段代码确保了用户无法输入超过10个字符。是不是很酷？ 😎 通过遵循系统协议，你能够轻松地为你的应用添加强大的交互功能，让用户体验更上一层楼！</p>`,15)]))}const c=s(l,[["render",n]]);export{o as __pageData,c as default};
