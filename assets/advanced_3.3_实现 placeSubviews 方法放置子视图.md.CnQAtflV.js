import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.Bw-5EFTY.js";const E=JSON.parse('{"title":"实现 placeSubviews 方法放置子视图","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/3.3_实现 placeSubviews 方法放置子视图.md","filePath":"advanced/3.3_实现 placeSubviews 方法放置子视图.md"}'),l={name:"advanced/3.3_实现 placeSubviews 方法放置子视图.md"};function p(t,s,h,k,r,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="实现-placesubviews-方法放置子视图" tabindex="-1">实现 placeSubviews 方法放置子视图 <a class="header-anchor" href="#实现-placesubviews-方法放置子视图" aria-label="Permalink to &quot;实现 placeSubviews 方法放置子视图&quot;">​</a></h1><h2 id="放置子视图的核心" tabindex="-1">放置子视图的核心 <a class="header-anchor" href="#放置子视图的核心" aria-label="Permalink to &quot;放置子视图的核心&quot;">​</a></h2><p><code>placeSubviews</code> 方法是自定义布局协议中至关重要的一环。 它负责将所有子视图精确地放置在布局容器内。 你将在这里定义每个子视图的最终位置和尺寸。 🚀</p><p>这个方法接收一个 <code>subviews</code> 集合和一个 <code>proposal</code> 参数。 <code>subviews</code> 包含了所有需要布局的子视图。 <code>proposal</code> 则提供了父视图建议的尺寸。</p><h2 id="理解放置逻辑" tabindex="-1">理解放置逻辑 <a class="header-anchor" href="#理解放置逻辑" aria-label="Permalink to &quot;理解放置逻辑&quot;">​</a></h2><p>在 <code>placeSubviews</code> 中，你需要遍历 <code>subviews</code> 集合。 对于每个子视图，你都需要计算它在布局中的具体位置。 这通常涉及到子视图的尺寸和布局容器的可用空间。</p><p>例如，你可以让所有子视图水平排列。 你会计算每个子视图的宽度，然后依次放置它们。 想象一下，你正在精心安排一个画廊，每幅画都有它独特的位置。 🖼️</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> placeSubviews</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bounds: CGRect, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">proposal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ProposedViewSize, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subviews</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Subviews) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xOffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bounds.minX</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subview </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subviews {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subviewSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subview.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sizeThatFits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proposal)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        subview.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">place</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">at</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CGPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: xOffset, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: bounds.midY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subviewSize.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">proposal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: proposal)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        xOffset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subviewSize.width</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="实际应用与技巧" tabindex="-1">实际应用与技巧 <a class="header-anchor" href="#实际应用与技巧" aria-label="Permalink to &quot;实际应用与技巧&quot;">​</a></h2><p><code>placeSubviews</code> 的灵活性令人惊叹。 你可以实现各种复杂的布局效果。 比如，你可以创建网格布局、圆形布局，甚至是自定义的堆叠布局。 可能性是无限的！ ✨</p><ul><li><strong>动态调整</strong>: 根据 <code>proposal</code> 的尺寸动态调整子视图的位置。</li><li><strong>对齐方式</strong>: 实现不同的对齐方式，如居中、靠左或靠右。</li><li><strong>间距控制</strong>: 在子视图之间添加自定义间距，让布局更美观。</li></ul><p>大约 75% 的自定义布局逻辑都集中在 <code>placeSubviews</code> 中。 掌握它，你就掌握了自定义布局的核心。</p><h2 id="性能优化考量" tabindex="-1">性能优化考量 <a class="header-anchor" href="#性能优化考量" aria-label="Permalink to &quot;性能优化考量&quot;">​</a></h2><p>在实现 <code>placeSubviews</code> 时，性能是一个重要的考量因素。 避免在循环中进行昂贵的计算。 尽量重用已计算的值。 优化你的布局代码，确保流畅的用户体验。 ⚡</p><ul><li><strong>缓存计算</strong>: 如果某些尺寸或位置可以预先计算，请缓存它们。</li><li><strong>避免不必要的重绘</strong>: 只有当布局真正需要更新时才触发重绘。</li><li><strong>使用 <code>subview.sizeThatFits</code></strong>: 总是使用 <code>subview.sizeThatFits</code> 来获取子视图的理想尺寸，而不是硬编码。</li></ul><p>通过这些技巧，你的自定义布局将既强大又高效。 🚀 持续学习和实践，你将成为 SwiftUI 布局大师！</p>`,16)]))}const c=i(l,[["render",p]]);export{E as __pageData,c as default};
