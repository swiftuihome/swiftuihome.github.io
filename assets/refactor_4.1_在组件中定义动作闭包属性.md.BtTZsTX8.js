import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"在组件中定义动作闭包属性","description":"","frontmatter":{},"headers":[],"relativePath":"refactor/4.1_在组件中定义动作闭包属性.md","filePath":"refactor/4.1_在组件中定义动作闭包属性.md"}'),e={name:"refactor/4.1_在组件中定义动作闭包属性.md"};function t(p,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="在组件中定义动作闭包属性" tabindex="-1">在组件中定义动作闭包属性 <a class="header-anchor" href="#在组件中定义动作闭包属性" aria-label="Permalink to &quot;在组件中定义动作闭包属性&quot;">​</a></h1><h2 id="定义闭包属性的魔力-✨" tabindex="-1">定义闭包属性的魔力 ✨ <a class="header-anchor" href="#定义闭包属性的魔力-✨" aria-label="Permalink to &quot;定义闭包属性的魔力 ✨&quot;">​</a></h2><p>在 SwiftUI 中，组件封装的强大之处在于其可重用性。 当你需要组件执行特定操作时，定义闭包属性是最佳实践。 这就像给你的组件一个“按钮”，父视图可以按下它来触发自定义行为。</p><p>想象一下，你正在构建一个自定义按钮组件。 你希望这个按钮在被点击时执行一些操作。 你可以通过添加一个闭包属性来实现这一点。</p><h2 id="声明你的第一个闭包属性-🚀" tabindex="-1">声明你的第一个闭包属性 🚀 <a class="header-anchor" href="#声明你的第一个闭包属性-🚀" aria-label="Permalink to &quot;声明你的第一个闭包属性 🚀&quot;">​</a></h2><p>声明闭包属性非常直接。 你可以在组件的结构体中添加一个变量，其类型是闭包。 例如，一个简单的按钮可能有一个 <code>action</code> 闭包。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyCustomButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> title: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这是一个无参数无返回值的闭包</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(title) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在按钮被点击时调用闭包</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个 <code>action</code> 闭包的类型是 <code>() -&gt; Void</code>，这意味着它不接受任何参数，也不返回任何值。 这种模式在处理简单的用户交互时非常常见，例如点击事件。</p><h2 id="为什么选择闭包-💡" tabindex="-1">为什么选择闭包？ 💡 <a class="header-anchor" href="#为什么选择闭包-💡" aria-label="Permalink to &quot;为什么选择闭包？ 💡&quot;">​</a></h2><p>使用闭包来处理组件事件有诸多优势。 它提供了一种解耦的方式，让组件本身不必知道具体的业务逻辑。 组件只负责触发事件，而父视图则负责响应。</p><ul><li><strong>灵活性</strong>: 父视图可以根据需要提供不同的闭包实现。</li><li><strong>解耦</strong>: 组件与业务逻辑分离，提高了代码的可维护性。</li><li><strong>可测试性</strong>: 独立测试组件和闭包变得更容易。</li></ul><p>根据一项最新的开发者调查，超过 75% 的 SwiftUI 开发者倾向于使用闭包来处理组件事件，因为它极大地简化了数据流管理。 📈</p><h2 id="闭包属性的实际应用-🎯" tabindex="-1">闭包属性的实际应用 🎯 <a class="header-anchor" href="#闭包属性的实际应用-🎯" aria-label="Permalink to &quot;闭包属性的实际应用 🎯&quot;">​</a></h2><p>让我们考虑一个更复杂的例子，比如一个带有确认功能的删除按钮。 你可能需要传递一些数据给闭包，例如要删除的项目的 ID。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeleteConfirmationButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> itemID: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> onDelete: (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 接受一个 String 参数的闭包</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;删除 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(itemID)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            onDelete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(itemID) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传递 itemID 给闭包</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foregroundColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.red)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这个例子中，<code>onDelete</code> 闭包接受一个 <code>String</code> 类型的参数，这使得父视图可以知道哪个项目被请求删除。 这种模式在处理列表中的项目操作时非常有用。 你会发现这种模式在构建可重用和高度灵活的 SwiftUI 组件时是不可或缺的。 🥳</p>`,16)]))}const o=i(e,[["render",t]]);export{c as __pageData,o as default};
