import{_ as e,c as a,o as i,ag as n}from"./chunks/framework.ymCRTBvy.js";const k=JSON.parse('{"title":"使用@StateObject或@ObservedObject订阅ViewModel","description":"","frontmatter":{},"headers":[],"relativePath":"network/5.4_在视图中使用@StateObject或@ObservedObject订阅ViewModel.md","filePath":"network/5.4_在视图中使用@StateObject或@ObservedObject订阅ViewModel.md"}'),t={name:"network/5.4_在视图中使用@StateObject或@ObservedObject订阅ViewModel.md"};function l(p,s,d,r,h,c){return i(),a("div",null,s[0]||(s[0]=[n(`<h1 id="使用-stateobject或-observedobject订阅viewmodel" tabindex="-1">使用@StateObject或@ObservedObject订阅ViewModel <a class="header-anchor" href="#使用-stateobject或-observedobject订阅viewmodel" aria-label="Permalink to &quot;使用@StateObject或@ObservedObject订阅ViewModel&quot;">​</a></h1><p>在SwiftUI中，状态管理是构建动态用户界面的关键。通过使用<code>@StateObject</code>和<code>@ObservedObject</code>，你可以轻松地将视图与ViewModel连接，从而实现数据的实时更新。</p><h2 id="_1-stateobject的使用" tabindex="-1">1. @StateObject的使用 <a class="header-anchor" href="#_1-stateobject的使用" aria-label="Permalink to &quot;1. @StateObject的使用&quot;">​</a></h2><p><code>@StateObject</code>用于在视图中创建一个新的ViewModel实例。它确保ViewModel的生命周期与视图相同。当视图首次加载时，<code>@StateObject</code>会初始化ViewModel，并在视图的整个生命周期内保持该实例。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @StateObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyViewModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(viewModel.data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">onAppear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                viewModel.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中，<code>MyViewModel</code>是一个遵循<code>ObservableObject</code>协议的类。<code>fetchData()</code>方法用于从网络获取数据并更新<code>data</code>属性。</p><h2 id="_2-observedobject的使用" tabindex="-1">2. @ObservedObject的使用 <a class="header-anchor" href="#_2-observedobject的使用" aria-label="Permalink to &quot;2. @ObservedObject的使用&quot;">​</a></h2><p><code>@ObservedObject</code>用于在视图中观察一个已经存在的ViewModel实例。它适用于当ViewModel在其他地方创建时，你希望在视图中使用它。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DetailView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @ObservedObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewModel: MyViewModel</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(viewModel.data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在这个例子中，<code>DetailView</code>接收一个<code>MyViewModel</code>实例作为参数。每当<code>data</code>属性发生变化时，视图会自动更新。</p><h2 id="_3-选择合适的属性包装器" tabindex="-1">3. 选择合适的属性包装器 <a class="header-anchor" href="#_3-选择合适的属性包装器" aria-label="Permalink to &quot;3. 选择合适的属性包装器&quot;">​</a></h2><ul><li><strong>@StateObject</strong>: 当你需要在视图中创建和管理ViewModel的生命周期时使用。</li><li><strong>@ObservedObject</strong>: 当ViewModel在其他地方创建并传递给视图时使用。</li></ul><h2 id="_4-实际应用场景" tabindex="-1">4. 实际应用场景 <a class="header-anchor" href="#_4-实际应用场景" aria-label="Permalink to &quot;4. 实际应用场景&quot;">​</a></h2><p>在实际应用中，使用<code>@StateObject</code>和<code>@ObservedObject</code>可以帮助你实现以下功能：</p><ul><li><strong>数据绑定</strong>: 通过将ViewModel与视图绑定，任何数据的变化都会自动反映在UI上。</li><li><strong>简化状态管理</strong>: 你可以将复杂的状态逻辑封装在ViewModel中，使视图代码更加简洁。</li><li><strong>提高可重用性</strong>: ViewModel可以在多个视图之间共享，减少代码重复。</li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>通过合理使用<code>@StateObject</code>和<code>@ObservedObject</code>，你可以有效地管理SwiftUI中的状态，提升应用的响应性和用户体验。无论是创建新的ViewModel还是观察现有的实例，这两种属性包装器都能帮助你构建更为动态和交互的界面。继续探索SwiftUI的强大功能吧！🚀</p>`,17)]))}const b=e(t,[["render",l]]);export{k as __pageData,b as default};
