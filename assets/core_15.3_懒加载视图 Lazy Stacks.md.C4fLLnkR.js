import{_ as s,c as i,o as e,ag as t}from"./chunks/framework.ymCRTBvy.js";const o=JSON.parse('{"title":"懒加载视图 Lazy Stacks","description":"","frontmatter":{},"headers":[],"relativePath":"core/15.3_懒加载视图 Lazy Stacks.md","filePath":"core/15.3_懒加载视图 Lazy Stacks.md"}'),n={name:"core/15.3_懒加载视图 Lazy Stacks.md"};function l(c,a,p,k,h,d){return e(),i("div",null,a[0]||(a[0]=[t(`<h1 id="懒加载视图-lazy-stacks" tabindex="-1">懒加载视图 Lazy Stacks <a class="header-anchor" href="#懒加载视图-lazy-stacks" aria-label="Permalink to &quot;懒加载视图 Lazy Stacks&quot;">​</a></h1><h2 id="懒加载视图-lazy-stacks-1" tabindex="-1">懒加载视图 Lazy Stacks <a class="header-anchor" href="#懒加载视图-lazy-stacks-1" aria-label="Permalink to &quot;懒加载视图 Lazy Stacks&quot;">​</a></h2><p>在 SwiftUI 中，<code>LazyVStack</code> 和 <code>LazyHStack</code> 是强大的工具，可以显著提升你的 App 性能。它们只在视图即将显示在屏幕上时才加载，避免了不必要的资源消耗。想象一下，你有一个包含成百上千个条目的列表，如果一次性全部加载，App 可能会变得卡顿。使用 <code>LazyVStack</code>，你可以只加载屏幕上可见的条目，从而实现流畅的滚动体验。🚀</p><h2 id="为什么使用-lazy-stacks" tabindex="-1">为什么使用 Lazy Stacks？ <a class="header-anchor" href="#为什么使用-lazy-stacks" aria-label="Permalink to &quot;为什么使用 Lazy Stacks？&quot;">​</a></h2><p>使用 <code>Lazy Stacks</code> 的主要优势在于性能优化。当处理大量数据或复杂视图时，它们可以显著减少初始加载时间和内存占用。这对于提升用户体验至关重要，尤其是在资源有限的设备上。例如，一个包含 1000 个条目的列表，如果每个条目都包含图片和文本，那么一次性加载所有条目可能会导致 App 崩溃。使用 <code>LazyVStack</code>，你可以按需加载，确保 App 运行流畅。</p><ul><li>减少初始加载时间</li><li>降低内存占用</li><li>提升滚动性能</li></ul><h2 id="如何使用-lazyvstack-和-lazyhstack" tabindex="-1">如何使用 LazyVStack 和 LazyHStack <a class="header-anchor" href="#如何使用-lazyvstack-和-lazyhstack" aria-label="Permalink to &quot;如何使用 LazyVStack 和 LazyHStack&quot;">​</a></h2><p><code>LazyVStack</code> 和 <code>LazyHStack</code> 的使用非常简单。它们与 <code>VStack</code> 和 <code>HStack</code> 类似，但具有懒加载的特性。你只需要将 <code>VStack</code> 或 <code>HStack</code> 替换为 <code>LazyVStack</code> 或 <code>LazyHStack</code> 即可。例如：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ScrollView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    LazyVStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        ForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(index)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子中，只有当 <code>Text</code> 视图即将显示在屏幕上时，才会被加载。这大大提高了滚动性能。🎉</p><h2 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h2><p><code>Lazy Stacks</code> 在许多场景中都非常有用。例如，在显示大型数据集、图片列表或复杂的用户界面时，它们可以显著提升性能。考虑一个电商 App，其中包含数千个商品。使用 <code>LazyVStack</code>，你可以只加载用户当前浏览的商品，从而实现快速的滚动和响应。</p><ol><li>大型数据集的展示</li><li>图片列表的优化</li><li>复杂用户界面的构建</li></ol><p>总而言之，<code>LazyVStack</code> 和 <code>LazyHStack</code> 是 SwiftUI 中不可或缺的性能优化工具。通过按需加载视图，你可以显著提升 App 的性能和用户体验。 记住，优化是持续的过程，使用 <code>Lazy Stacks</code> 是一个良好的开端！👍</p>`,14)]))}const y=s(n,[["render",l]]);export{o as __pageData,y as default};
