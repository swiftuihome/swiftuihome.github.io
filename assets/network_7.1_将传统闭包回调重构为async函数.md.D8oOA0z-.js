import{_ as a,c as i,o as n,ag as l}from"./chunks/framework.Bw-5EFTY.js";const E=JSON.parse('{"title":"将传统闭包回调重构为async函数","description":"","frontmatter":{},"headers":[],"relativePath":"network/7.1_将传统闭包回调重构为async函数.md","filePath":"network/7.1_将传统闭包回调重构为async函数.md"}'),t={name:"network/7.1_将传统闭包回调重构为async函数.md"};function p(e,s,h,k,r,d){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="将传统闭包回调重构为async函数" tabindex="-1">将传统闭包回调重构为async函数 <a class="header-anchor" href="#将传统闭包回调重构为async函数" aria-label="Permalink to &quot;将传统闭包回调重构为async函数&quot;">​</a></h1><p>在Swift中，传统的闭包回调方式常常使得异步代码变得复杂且难以维护。通过将这些闭包重构为async函数，我们可以显著简化代码结构，提高可读性和可维护性。✨</p><h2 id="_1-理解闭包回调" tabindex="-1">1. 理解闭包回调 <a class="header-anchor" href="#_1-理解闭包回调" aria-label="Permalink to &quot;1. 理解闭包回调&quot;">​</a></h2><p>闭包回调是一种常见的异步编程模式。它允许你在某个操作完成后执行特定的代码。例如，网络请求完成后，你可能会使用闭包来处理返回的数据：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@escaping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 模拟网络请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DispatchQueue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设获取到的数据</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这种方式虽然有效，但在多个嵌套的闭包中，代码会变得难以阅读和调试。</p><h2 id="_2-使用async-await重构" tabindex="-1">2. 使用async/await重构 <a class="header-anchor" href="#_2-使用async-await重构" aria-label="Permalink to &quot;2. 使用async/await重构&quot;">​</a></h2><p>通过使用async/await，我们可以将上述代码重构为更简洁的形式。首先，我们需要将函数声明为async，并使用await来调用异步操作：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> withCheckedContinuation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { continuation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DispatchQueue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设获取到的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            continuation.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">resume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">returning</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子中，<code>withCheckedContinuation</code>帮助我们将闭包转换为async函数，使得代码更加直观。</p><h2 id="_3-调用async函数" tabindex="-1">3. 调用async函数 <a class="header-anchor" href="#_3-调用async函数" aria-label="Permalink to &quot;3. 调用async函数&quot;">​</a></h2><p>调用async函数时，你需要在一个异步上下文中进行。可以在<code>Task</code>中调用它：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这种方式使得异步代码的执行顺序更加清晰，避免了回调地狱的问题。</p><h2 id="_4-优势与总结" tabindex="-1">4. 优势与总结 <a class="header-anchor" href="#_4-优势与总结" aria-label="Permalink to &quot;4. 优势与总结&quot;">​</a></h2><ul><li><strong>可读性</strong>：async/await使得异步代码看起来像同步代码，易于理解。</li><li><strong>错误处理</strong>：使用do-catch语句可以更方便地处理错误。</li><li><strong>维护性</strong>：减少了嵌套层级，使得代码更易于维护。</li></ul><p>通过将传统的闭包回调重构为async函数，你将能够编写出更简洁、更易于维护的代码。💪 这种方法不仅提高了代码的可读性，还使得错误处理变得更加简单。快来尝试吧！🚀</p>`,17)]))}const y=a(t,[["render",p]]);export{E as __pageData,y as default};
