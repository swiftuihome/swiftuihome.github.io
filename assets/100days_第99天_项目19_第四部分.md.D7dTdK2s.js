import{_ as o,c as l,o as i,ag as t}from"./chunks/framework.Bw-5EFTY.js";const u=JSON.parse('{"title":"第99天 项目 19 第四部分","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第99天_项目19_第四部分.md","filePath":"100days/第99天_项目19_第四部分.md"}'),r={name:"100days/第99天_项目19_第四部分.md"};function n(a,e,s,d,c,p){return i(),l("div",null,e[0]||(e[0]=[t('<h1 id="第99天-项目-19-第四部分" tabindex="-1">第99天 项目 19 第四部分 <a class="header-anchor" href="#第99天-项目-19-第四部分" aria-label="Permalink to &quot;第99天 项目 19 第四部分&quot;">​</a></h1><p>现在我们的应用程序已经完成，接下来是时候接受一些挑战来巩固你的知识，然后进行一个小测试，确保你记住所学的内容。</p><p>虽然这次的前两个挑战相当简单，但我认为第三个挑战会更有难度。希望在过去99天的学习中，你已经培养出了坚定的毅力，但即便如此，也希望你记住，失败并不可怕——正如西班牙作家何塞·贝尔加明所说：“做好失败的准备，就是为成功做准备。”</p><p>今天，你需要完成第19个项目的总结章节，完成相关复习，然后攻克所有三个挑战。</p><ul><li>SnowSeeker 项目总结</li><li>SnowSeeker 项目复习</li></ul><h2 id="snowseeker-项目总结" tabindex="-1">SnowSeeker 项目总结 <a class="header-anchor" href="#snowseeker-项目总结" aria-label="Permalink to &quot;SnowSeeker 项目总结&quot;">​</a></h2><p>作者：Paul Hudson 2024年3月17日</p><p>这个项目并不是特别复杂，但它仍然教授了一些新技能，例如分栏视图布局、可选警报、透明组布局、自定义环境类，甚至还有一种改进的文本列表格式化方式。同时，它也为你提供了练习许多核心技能的机会，比如处理<code>Codable</code>、创建滚动列表等等。</p><p>这类应用程序非常适合作为模板，因为它是那种你未来只需改变输入的内容类型，就可以反复使用的应用。模板应用程序以及其背后的技术，是iOS应用程序的“核心基础”：这种应用或许永远不会引起轰动，但它又非常实用且常见，是你不可或缺的工具。</p><h2 id="复习所学内容" tabindex="-1">复习所学内容 <a class="header-anchor" href="#复习所学内容" aria-label="Permalink to &quot;复习所学内容&quot;">​</a></h2><p>任何人都能看完一个教程，但要记住所学的知识，还需要付出实际的努力。我的职责是确保你能从这些教程中收获尽可能多的知识，完成后面的练习题可以帮助你检验自己的学习成果。</p><h2 id="挑战" tabindex="-1">挑战 <a class="header-anchor" href="#挑战" aria-label="Permalink to &quot;挑战&quot;">​</a></h2><p>学习的最佳方式之一就是尽可能多地编写自己的代码，因此我准备了三种扩展这个应用程序的方式，确保你完全理解其中的原理。</p><ol><li>在<code>ResortView</code>图像上方添加图片版权信息。相关数据已从JSON中加载，你只需让它在界面上呈现出良好的效果即可。</li><li>完善<code>Favorites</code>的加载和保存方法。</li><li>这是一个真正有难度的挑战：让用户能够在<code>ContentView</code>中对度假村进行排序，可以选择默认顺序、按字母顺序排序，或者按国家顺序排序。</li></ol><h2 id="snowseeker-项目练习题" tabindex="-1">SnowSeeker 项目练习题 <a class="header-anchor" href="#snowseeker-项目练习题" aria-label="Permalink to &quot;SnowSeeker 项目练习题&quot;">​</a></h2><p>问题1/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：所有iPhone在竖屏模式下都采用紧凑宽度尺寸类。</strong></li><li><strong>选项2：<code>alert()</code>不支持可选数据。</strong></li></ul><p>问题2/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：在同一类型中，一个<code>static let</code>属性可以引用另一个<code>static let</code>属性。</strong></li><li><strong>选项2：iPad的尺寸类配置与iPhone完全相同。</strong></li></ul><p>问题3/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：由SF Symbols图标生成的图像具有可自定义的前景样式。</strong></li><li><strong>选项2：我们无法向SwiftUI视图添加计算属性。</strong></li></ul><p>问题4/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：如果需要从环境中获取<code>@Observable</code>类的绑定，我们应该使用<code>@Binding</code>。</strong></li><li><strong>选项2：最大尺寸的iPhone（Max和Plus型号）在横屏模式下采用常规水平尺寸类。</strong></li></ul><p>问题5/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：<code>static let</code>属性始终是延迟创建的。</strong></li><li><strong>选项2：将属性标记为<code>private</code>意味着只有同一文件中的其他代码可以使用它。</strong></li></ul><p>问题6/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：SwiftUI可以在单个<code>NavigationSplitView</code>中并排显示四个视图。</strong></li><li><strong>选项2：我们可以使用<code>dynamicTypeSize()</code>修饰符来声明视图支持的动态类型尺寸。</strong></li></ul><p>问题7/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：在iPad上，使用<code>NavigationSplitView</code>通常比使用<code>NavigationStack</code>效果更好。</strong></li><li><strong>选项2：动态类型（Dynamic Type）提供五种不同的文本尺寸，我们需要全部支持。</strong></li></ul><p>问题8/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：添加搜索栏可使用<code>searchable()</code>修饰符。</strong></li><li><strong>选项2：添加搜索栏可使用<code>searching()</code>修饰符。</strong></li></ul><p>问题9/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：SwiftUI无法在<code>Text</code>视图中显示字符串数组。</strong></li><li><strong>选项2：我们可以将<code>alert()</code>修饰符绑定到可选值。</strong></li></ul><p>问题10/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：所有iOS设备都具有水平和垂直尺寸类。</strong></li><li><strong>选项2：<code>Group</code>始终会将其包含的视图水平排列，除非另行指定。</strong></li></ul><p>问题11/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：如果将视图放置在<code>Group</code>内部，父视图会决定这些子视图的布局方式。</strong></li><li><strong>选项2：<code>NavigationLink</code>的目标视图始终会在当前视图中显示。</strong></li></ul><p>问题12/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1：使用<code>@Environment(YourObservableClass.self)</code>创建属性，当该类的属性发生变化时，该属性会保持更新。</strong></li><li><strong>选项2：<code>VStack</code>可以设置对齐方式或间距，但不能同时设置两者。</strong></li></ul>',39)]))}const _=o(r,[["render",n]]);export{u as __pageData,_ as default};
