import{_ as e,c as i,o as a,ag as n}from"./chunks/framework.Bw-5EFTY.js";const d=JSON.parse('{"title":"使用 .anchorPreference 传递锚点","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/4.2_使用 .anchorPreference 传递锚点.md","filePath":"advanced/4.2_使用 .anchorPreference 传递锚点.md"}'),r={name:"advanced/4.2_使用 .anchorPreference 传递锚点.md"};function t(l,s,h,p,k,c){return a(),i("div",null,s[0]||(s[0]=[n(`<h1 id="使用-anchorpreference-传递锚点" tabindex="-1">使用 .anchorPreference 传递锚点 <a class="header-anchor" href="#使用-anchorpreference-传递锚点" aria-label="Permalink to &quot;使用 .anchorPreference 传递锚点&quot;">​</a></h1><h2 id="锚点偏好设置的强大功能" tabindex="-1">锚点偏好设置的强大功能 <a class="header-anchor" href="#锚点偏好设置的强大功能" aria-label="Permalink to &quot;锚点偏好设置的强大功能&quot;">​</a></h2><p>在 SwiftUI 中，<code>.anchorPreference</code> 修饰符是实现视图间精确对齐的关键工具。它允许你从子视图中提取几何信息，并将其传递给父视图或祖先视图。这就像给你的视图贴上一个“标签”，上面写着它的位置和大小信息，然后让其他视图来读取这些标签。 🏷️</p><p>想象一下，你需要将一个视图的底部与另一个视图的顶部对齐。使用 <code>.anchorPreference</code>，你可以轻松实现这一点。</p><h2 id="如何使用-anchorpreference" tabindex="-1">如何使用 .anchorPreference <a class="header-anchor" href="#如何使用-anchorpreference" aria-label="Permalink to &quot;如何使用 .anchorPreference&quot;">​</a></h2><p>使用 <code>.anchorPreference</code> 需要三个核心组件：</p><ul><li><strong>一个键 (Key)</strong>：这是一个遵循 <code>PreferenceKey</code> 协议的类型。它定义了你想要传递的数据类型以及如何合并多个值。</li><li><strong>一个值 (Value)</strong>：这是你想要从视图中提取的锚点信息。通常是 <code>Anchor&lt;CGPoint&gt;</code> 或 <code>Anchor&lt;CGRect&gt;</code>。</li><li><strong>一个闭包 (Closure)</strong>：这个闭包接收一个 <code>GeometryProxy</code> 对象，并返回你想要存储在偏好设置中的值。</li></ul><p>例如，你可以定义一个键来存储视图的中心点：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CenterPreferenceKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PreferenceKey </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> defaultValue: CGPoint</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CGPoint</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CGPoint</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>然后，在你的视图上应用 <code>.anchorPreference</code>：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">anchorPreference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CenterPreferenceKey.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .center) { anchor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        anchor.center</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="传递锚点信息" tabindex="-1">传递锚点信息 <a class="header-anchor" href="#传递锚点信息" aria-label="Permalink to &quot;传递锚点信息&quot;">​</a></h2><p><code>.anchorPreference</code> 的强大之处在于它能够将子视图的几何信息“冒泡”到视图层级结构中。当一个视图使用 <code>.anchorPreference</code> 时，它会将指定的值存储在一个特殊的“偏好设置存储”中。父视图可以通过 <code>.onPreferenceChange</code> 或 <code>GeometryReader</code> 来读取这些偏好设置。</p><ul><li><strong><code>.onPreferenceChange</code></strong>: 当偏好设置的值发生变化时，你可以执行一些操作。</li><li><strong><code>GeometryReader</code></strong>: 在 <code>GeometryReader</code> 内部，你可以访问到所有子视图传递上来的锚点信息。</li></ul><p>例如，你可以创建一个自定义布局，根据子视图的锚点来排列它们。这为复杂的布局需求提供了极大的灵活性。 🚀</p><h2 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h2><p><code>.anchorPreference</code> 在许多高级布局场景中都非常有用，例如：</p><ol><li><strong>创建连接线</strong>：在两个不相关的视图之间绘制一条线，将它们连接起来。</li><li><strong>自定义对齐</strong>：实现比 SwiftUI 内置对齐方式更复杂的对齐逻辑。</li><li><strong>动态布局</strong>：根据子视图的实际大小和位置来调整父视图的布局。</li></ol><p>通过熟练掌握 <code>.anchorPreference</code>，你将能够构建出更具动态性和交互性的 SwiftUI 界面。它为你打开了自定义布局的无限可能！ 🌟</p>`,19)]))}const E=e(r,[["render",t]]);export{d as __pageData,E as default};
