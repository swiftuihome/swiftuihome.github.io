import{_ as s,c as a,o as e,ag as p}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"理解viewWillAppear和viewDidAppear的作用","description":"","frontmatter":{},"headers":[],"relativePath":"swift/uikit/advanced/2.3_理解viewWillAppear和viewDidAppear的作用.md","filePath":"swift/uikit/advanced/2.3_理解viewWillAppear和viewDidAppear的作用.md"}'),l={name:"swift/uikit/advanced/2.3_理解viewWillAppear和viewDidAppear的作用.md"};function n(r,i,t,h,d,k){return e(),a("div",null,i[0]||(i[0]=[p(`<h1 id="理解viewwillappear和viewdidappear的作用" tabindex="-1">理解viewWillAppear和viewDidAppear的作用 <a class="header-anchor" href="#理解viewwillappear和viewdidappear的作用" aria-label="Permalink to &quot;理解viewWillAppear和viewDidAppear的作用&quot;">​</a></h1><blockquote><p>在 iOS 开发中，<code>viewWillAppear</code> 和 <code>viewDidAppear</code> 是视图控制器生命周期中非常重要的两个方法。它们在视图即将显示和已经显示在屏幕上时被调用。理解它们的作用，能帮助你更好地管理视图的显示和动画效果。🎉</p></blockquote><h2 id="viewwillappear-视图即将显示" tabindex="-1">viewWillAppear：视图即将显示 <a class="header-anchor" href="#viewwillappear-视图即将显示" aria-label="Permalink to &quot;viewWillAppear：视图即将显示&quot;">​</a></h2><p><code>viewWillAppear(_ animated: Bool)</code> 方法在视图控制器的视图即将添加到视图层级结构中，并且即将显示在屏幕上时调用。你可以利用这个方法在视图真正显示之前进行一些准备工作。例如，你可以：</p><ul><li>更新视图的数据。</li><li>启动动画效果。</li><li>调整视图的布局。</li></ul><p><strong>示例：</strong></p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> viewWillAppear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animated: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viewWillAppear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animated)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 启动一个简单的淡入动画</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.alpha </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    UIView.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">withDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.alpha </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子中，我们在 <code>viewWillAppear</code> 中将视图的透明度设置为 0，然后在动画块中将透明度设置为 1，从而实现一个淡入的效果。</p><h2 id="viewdidappear-视图已经显示" tabindex="-1">viewDidAppear：视图已经显示 <a class="header-anchor" href="#viewdidappear-视图已经显示" aria-label="Permalink to &quot;viewDidAppear：视图已经显示&quot;">​</a></h2><p><code>viewDidAppear(_ animated: Bool)</code> 方法在视图控制器的视图已经完全显示在屏幕上时调用。这个方法非常适合执行一些只需要在视图完全显示后才需要执行的操作。例如：</p><ul><li>开始网络请求。</li><li>显示用户引导。</li><li>记录用户行为。</li></ul><p><strong>示例：</strong></p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> viewDidAppear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animated: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viewDidAppear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animated)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 视图完全显示后，开始请求数据</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在这个例子中，我们在 <code>viewDidAppear</code> 中调用 <code>fetchData()</code> 方法，开始从服务器获取数据。</p><h2 id="区分-viewwillappear-和-viewdidappear" tabindex="-1">区分 viewWillAppear 和 viewDidAppear <a class="header-anchor" href="#区分-viewwillappear-和-viewdidappear" aria-label="Permalink to &quot;区分 viewWillAppear 和 viewDidAppear&quot;">​</a></h2><p>虽然 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 都是在视图显示时调用的方法，但它们之间存在着重要的区别：</p><ol><li><strong>调用时机不同：</strong> <code>viewWillAppear</code> 在视图即将显示时调用，而 <code>viewDidAppear</code> 在视图已经显示后调用。</li><li><strong>用途不同：</strong> <code>viewWillAppear</code> 适合进行一些准备工作，例如更新数据和启动动画，而 <code>viewDidAppear</code> 适合执行一些只需要在视图完全显示后才需要执行的操作，例如开始网络请求和显示用户引导。</li></ol><h2 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h2><ul><li><strong>数据刷新：</strong> 你可以在 <code>viewWillAppear</code> 中刷新视图的数据，确保每次视图显示时都是最新的。</li><li><strong>动画效果：</strong> 你可以在 <code>viewWillAppear</code> 中启动动画效果，例如淡入、滑动等，让视图的显示更加生动。</li><li><strong>用户引导：</strong> 你可以在 <code>viewDidAppear</code> 中显示用户引导，帮助用户了解视图的功能和使用方法。</li><li><strong>性能优化：</strong> 对于一些耗时的操作，例如网络请求，你可以在 <code>viewDidAppear</code> 中执行，避免阻塞视图的显示。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>viewWillAppear</code> 和 <code>viewDidAppear</code> 是视图控制器生命周期中非常重要的两个方法。理解它们的作用，能帮助你更好地管理视图的显示和动画效果，提升用户体验。希望你能灵活运用这两个方法，打造出更加优秀的 iOS 应用！🚀</p>`,21)]))}const E=s(l,[["render",n]]);export{c as __pageData,E as default};
