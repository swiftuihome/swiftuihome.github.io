import{_ as o,c as i,o as t,ag as l}from"./chunks/framework.Bw-5EFTY.js";const V=JSON.parse('{"title":"将业务逻辑和状态从View迁移到ViewModel","description":"","frontmatter":{},"headers":[],"relativePath":"refactor/13.2_将业务逻辑和状态从View迁移到ViewModel.md","filePath":"refactor/13.2_将业务逻辑和状态从View迁移到ViewModel.md"}'),a={name:"refactor/13.2_将业务逻辑和状态从View迁移到ViewModel.md"};function d(r,e,s,n,c,w){return t(),i("div",null,e[0]||(e[0]=[l('<h1 id="将业务逻辑和状态从view迁移到viewmodel" tabindex="-1">将业务逻辑和状态从View迁移到ViewModel <a class="header-anchor" href="#将业务逻辑和状态从view迁移到viewmodel" aria-label="Permalink to &quot;将业务逻辑和状态从View迁移到ViewModel&quot;">​</a></h1><h2 id="告别臃肿的视图" tabindex="-1">告别臃肿的视图！ <a class="header-anchor" href="#告别臃肿的视图" aria-label="Permalink to &quot;告别臃肿的视图！&quot;">​</a></h2><p>将业务逻辑和状态从视图（View）中剥离，是构建可维护 SwiftUI 应用的关键一步。 想象一下，你的视图不再处理复杂的计算或数据管理，而是专注于 UI 呈现。 这将大大提升代码的清晰度和可测试性！ 🚀</p><h2 id="为什么需要迁移" tabindex="-1">为什么需要迁移？ <a class="header-anchor" href="#为什么需要迁移" aria-label="Permalink to &quot;为什么需要迁移？&quot;">​</a></h2><p>当视图变得过于庞大时，它会变得难以理解和维护。 试想一个包含数百行代码的视图，其中既有 UI 布局，又有数据请求和业务规则。 这简直是噩梦！ 😱</p><ul><li><strong>职责分离</strong>：将视图的职责限制在 UI 渲染上，而将业务逻辑和状态管理交给 ViewModel。</li><li><strong>提高可测试性</strong>：ViewModel 是纯 Swift 类，不依赖于 SwiftUI 视图生命周期，因此更容易进行单元测试。 你可以轻松模拟数据和测试业务规则。</li><li><strong>代码复用</strong>：同一个 ViewModel 可以被多个视图使用，从而减少重复代码。 例如，一个用户认证 ViewModel 可以被登录视图和注册视图共享。</li></ul><h2 id="迁移步骤详解" tabindex="-1">迁移步骤详解 <a class="header-anchor" href="#迁移步骤详解" aria-label="Permalink to &quot;迁移步骤详解&quot;">​</a></h2><p>将业务逻辑和状态从视图迁移到 ViewModel 的过程非常直接，但效果显著。 你会发现代码变得更加整洁和高效！</p><ol><li><strong>创建 ViewModel 类</strong>：首先，你需要创建一个新的 Swift 类，并使其遵循 <code>ObservableObject</code> 协议。 这是 ViewModel 的基础。</li><li><strong>定义 <code>@Published</code> 属性</strong>：将视图中所有需要被 UI 观察和更新的状态属性，迁移到 ViewModel 中，并使用 <code>@Published</code> 属性包装器标记它们。 例如，一个 <code>isLoading</code> 布尔值或一个 <code>userList</code> 数组。</li><li><strong>迁移业务逻辑</strong>：将视图中所有与数据处理、网络请求、数据验证等相关的函数和逻辑，剪切并粘贴到 ViewModel 中。 这些函数现在将直接操作 ViewModel 的 <code>@Published</code> 属性。</li><li><strong>视图引用 ViewModel</strong>：在你的 SwiftUI 视图中，使用 <code>@StateObject</code> 或 <code>@ObservedObject</code> 属性包装器来实例化或引用你的 ViewModel。 <code>@StateObject</code> 适用于 ViewModel 的生命周期与视图绑定，而 <code>@ObservedObject</code> 适用于 ViewModel 在外部创建并传入的情况。</li></ol><h2 id="实践中的优势" tabindex="-1">实践中的优势 <a class="header-anchor" href="#实践中的优势" aria-label="Permalink to &quot;实践中的优势&quot;">​</a></h2><p>这种模式带来了巨大的好处。 统计数据显示，采用 MVVM 模式的项目，其代码维护成本平均降低了 30%！ 📈</p><ul><li><strong>更清晰的结构</strong>：视图只负责“长什么样”，ViewModel 负责“做什么”。 这种分工让代码一目了然。</li><li><strong>更强的可扩展性</strong>：当需求变化时，你只需要修改 ViewModel 中的业务逻辑，而无需触碰视图的 UI 代码。</li><li><strong>团队协作更高效</strong>：前端开发者可以专注于 UI，后端开发者可以专注于 ViewModel 的逻辑，互不干扰。 🤝</li></ul><p>通过这些步骤，你将能够构建出更健壮、更易于维护的 SwiftUI 应用程序。 祝你编码愉快！ ✨</p>',13)]))}const h=o(a,[["render",d]]);export{V as __pageData,h as default};
