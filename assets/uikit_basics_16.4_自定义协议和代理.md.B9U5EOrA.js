import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"16.4_自定义协议和代理","description":"","frontmatter":{},"headers":[],"relativePath":"uikit/basics/16.4_自定义协议和代理.md","filePath":"uikit/basics/16.4_自定义协议和代理.md"}'),l={name:"uikit/basics/16.4_自定义协议和代理.md"};function p(t,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="_16-4-自定义协议和代理" tabindex="-1">16.4_自定义协议和代理 <a class="header-anchor" href="#_16-4-自定义协议和代理" aria-label="Permalink to &quot;16.4_自定义协议和代理&quot;">​</a></h1><blockquote><p>自定义协议和代理是 iOS 开发中实现对象间通信的强大工具。你可以把它想象成一个中间人，帮助两个对象在不直接了解对方的情况下进行交流。这使得你的代码更加模块化、灵活和易于维护。🎉</p></blockquote><h2 id="协议-protocol-的定义" tabindex="-1">协议 (Protocol) 的定义 <a class="header-anchor" href="#协议-protocol-的定义" aria-label="Permalink to &quot;协议 (Protocol) 的定义&quot;">​</a></h2><p>协议定义了一组方法和属性，任何类、结构体或枚举都可以遵循（adopt）这个协议。协议本身并不实现这些方法，而是要求遵循它的类型来实现。你可以把协议看作是一份合同，规定了遵循者必须提供的功能。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDelegateProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> didSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someProperty: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在这个例子中，<code>MyDelegateProtocol</code> 协议定义了一个名为 <code>didSomething</code> 的方法和一个名为 <code>someProperty</code> 的属性。任何遵循这个协议的类型都必须实现这个方法并提供这个属性。</p><h2 id="代理-delegate-的实现" tabindex="-1">代理 (Delegate) 的实现 <a class="header-anchor" href="#代理-delegate-的实现" aria-label="Permalink to &quot;代理 (Delegate) 的实现&quot;">​</a></h2><p>代理是一个对象，它遵循某个协议，并被另一个对象（委托者）持有。委托者在特定事件发生时，会调用代理对象中协议定义的方法，从而通知代理对象。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    weak</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delegate: MyDelegateProtocol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 声明代理属性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... 执行一些操作 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        delegate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">didSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;操作完成！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通知代理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子中，<code>MyClass</code> 类有一个 <code>delegate</code> 属性，类型为 <code>MyDelegateProtocol?</code>。<code>weak</code> 关键字是为了避免循环引用。当 <code>doSomething</code> 方法执行完毕后，它会调用代理对象的 <code>didSomething</code> 方法，并将数据传递给代理。</p><h2 id="遵循协议-adopting-protocol" tabindex="-1">遵循协议 (Adopting Protocol) <a class="header-anchor" href="#遵循协议-adopting-protocol" aria-label="Permalink to &quot;遵循协议 (Adopting Protocol)&quot;">​</a></h2><p>要使用自定义协议和代理，你需要创建一个类或结构体，并声明它遵循你的协议。然后，你需要实现协议中定义的所有方法和属性。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UIViewController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyDelegateProtocol </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someProperty: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> didSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;接收到数据：</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(data)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> viewDidLoad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viewDidLoad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        myObject.delegate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 设置代理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        myObject.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在这个例子中，<code>MyViewController</code> 类遵循了 <code>MyDelegateProtocol</code> 协议，并实现了 <code>didSomething</code> 方法和 <code>someProperty</code> 属性。在 <code>viewDidLoad</code> 方法中，我们创建了一个 <code>MyClass</code> 对象，并将 <code>MyViewController</code> 设置为它的代理。当 <code>MyClass</code> 对象调用 <code>doSomething</code> 方法时，<code>MyViewController</code> 的 <code>didSomething</code> 方法会被调用。</p><h2 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h2><p>自定义协议和代理在 iOS 开发中有很多应用场景，例如：</p><ol><li><strong>数据传递：</strong> 在不同的视图控制器之间传递数据。</li><li><strong>事件通知：</strong> 当某个事件发生时，通知其他对象。</li><li><strong>自定义控件：</strong> 创建自定义控件，并通过代理将控件的事件传递给父视图。</li></ol><p>例如，你可以使用代理来通知视图控制器，当用户点击了自定义按钮时，执行特定的操作。这使得你的代码更加清晰和易于维护。</p><p>总而言之，自定义协议和代理是 iOS 开发中非常重要的概念。通过理解和掌握它们，你可以编写出更加灵活、可维护和可扩展的代码。 🚀</p>`,19)]))}const E=i(l,[["render",p]]);export{c as __pageData,E as default};
