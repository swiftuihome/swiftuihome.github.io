import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bw-5EFTY.js";const o=JSON.parse('{"title":"滚动视图 ScrollView 与 ScrollViewReader","description":"","frontmatter":{},"headers":[],"relativePath":"core/8.1_滚动视图 ScrollView 与 ScrollViewReader.md","filePath":"core/8.1_滚动视图 ScrollView 与 ScrollViewReader.md"}'),e={name:"core/8.1_滚动视图 ScrollView 与 ScrollViewReader.md"};function p(h,s,r,t,k,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="滚动视图-scrollview-与-scrollviewreader" tabindex="-1">滚动视图 ScrollView 与 ScrollViewReader <a class="header-anchor" href="#滚动视图-scrollview-与-scrollviewreader" aria-label="Permalink to &quot;滚动视图 ScrollView 与 ScrollViewReader&quot;">​</a></h1><h2 id="探索-scrollview-的奥秘" tabindex="-1">探索 ScrollView 的奥秘 <a class="header-anchor" href="#探索-scrollview-的奥秘" aria-label="Permalink to &quot;探索 ScrollView 的奥秘&quot;">​</a></h2><p>SwiftUI 的 <code>ScrollView</code> 是构建可滚动内容区域的强大工具。它能让你轻松地展示超出屏幕范围的内容，无论是垂直还是水平方向。想象一下，你的应用需要显示长篇文章或大量图片，<code>ScrollView</code> 就能完美胜任！ 🚀</p><p>你可以通过简单的初始化来创建一个 <code>ScrollView</code>。例如，<code>ScrollView(.vertical)</code> 会创建一个垂直滚动的视图。你还可以指定滚动方向，比如 <code>.horizontal</code> 或同时支持两种方向。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ScrollView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.vertical) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    VStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        ForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;这是第 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(index)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 行内容&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.title)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这个例子展示了一个包含100行文本的垂直滚动视图。用户可以流畅地上下滑动，浏览所有内容。</p><h2 id="scrollviewreader-的魔法" tabindex="-1">ScrollViewReader 的魔法 <a class="header-anchor" href="#scrollviewreader-的魔法" aria-label="Permalink to &quot;ScrollViewReader 的魔法&quot;">​</a></h2><p><code>ScrollViewReader</code> 是一个非常实用的容器，它允许你以编程方式控制 <code>ScrollView</code> 的滚动位置。这就像给你的滚动视图一个遥控器！ 🎮</p><p>通过 <code>ScrollViewReader</code>，你可以轻松地滚动到特定的视图。这对于实现“回到顶部”按钮或导航到特定内容块的功能非常有用。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ScrollViewReader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { proxy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ScrollView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        VStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            ForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;项目 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(index)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 为每个视图设置一个唯一的ID</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.title2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;滚动到第 25 项&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                proxy.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scrollTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .center)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在这个例子中，我们为每个 <code>Text</code> 视图设置了一个唯一的 <code>id</code>。当点击按钮时，<code>proxy.scrollTo(25, anchor: .center)</code> 会将视图滚动到 ID 为 25 的项目，并将其居中显示。</p><h2 id="滚动行为的精细控制" tabindex="-1">滚动行为的精细控制 <a class="header-anchor" href="#滚动行为的精细控制" aria-label="Permalink to &quot;滚动行为的精细控制&quot;">​</a></h2><p><code>ScrollViewReader</code> 提供了多种滚动选项，让你能够精确控制滚动行为。你可以指定滚动到的位置，例如 <code>anchor: .top</code>、<code>anchor: .bottom</code> 或 <code>anchor: .center</code>。</p><ul><li><code>anchor: .top</code>: 将目标视图的顶部与滚动视图的顶部对齐。</li><li><code>anchor: .bottom</code>: 将目标视图的底部与滚动视图的底部对齐。</li><li><code>anchor: .center</code>: 将目标视图居中显示在滚动视图中。</li></ul><p>这些选项让你能够根据应用的需求，提供最佳的用户体验。例如，在一个聊天应用中，你可能希望新消息自动滚动到视图底部。</p><h2 id="性能优化小贴士" tabindex="-1">性能优化小贴士 <a class="header-anchor" href="#性能优化小贴士" aria-label="Permalink to &quot;性能优化小贴士&quot;">​</a></h2><p>在使用 <code>ScrollView</code> 时，考虑性能优化至关重要。尤其当内容量巨大时，惰性加载（Lazy Loading）可以显著提升性能。</p><ul><li>使用 <code>LazyVStack</code> 或 <code>LazyHStack</code>：这些容器只会在需要时才渲染视图，而不是一次性渲染所有内容。这能有效减少内存占用和渲染时间。</li><li>避免在滚动视图中进行昂贵的计算：尽量将计算密集型操作移出视图层级，或者使用缓存。</li></ul><p>通过这些技巧，你可以确保你的滚动视图既流畅又高效。 🚀 你的用户一定会喜欢这种无缝的体验！</p>`,19)]))}const E=i(e,[["render",p]]);export{o as __pageData,E as default};
