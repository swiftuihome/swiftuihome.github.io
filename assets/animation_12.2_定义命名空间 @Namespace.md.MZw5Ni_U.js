import{_ as a,c as s,o as i,ag as t}from"./chunks/framework.ymCRTBvy.js";const m=JSON.parse('{"title":"12.2_定义命名空间 @Namespace","description":"","frontmatter":{},"headers":[],"relativePath":"animation/12.2_定义命名空间 @Namespace.md","filePath":"animation/12.2_定义命名空间 @Namespace.md"}'),o={name:"animation/12.2_定义命名空间 @Namespace.md"};function n(c,e,d,r,p,l){return i(),s("div",null,e[0]||(e[0]=[t('<h1 id="_12-2-定义命名空间-namespace" tabindex="-1">12.2_定义命名空间 @Namespace <a class="header-anchor" href="#_12-2-定义命名空间-namespace" aria-label="Permalink to &quot;12.2_定义命名空间 @Namespace&quot;">​</a></h1><h2 id="探索-namespace-的奥秘-🚀" tabindex="-1">探索 @Namespace 的奥秘 🚀 <a class="header-anchor" href="#探索-namespace-的奥秘-🚀" aria-label="Permalink to &quot;探索 @Namespace 的奥秘 🚀&quot;">​</a></h2><p>在 SwiftUI 中，<code>@Namespace</code> 是一个强大的工具，它允许你在视图之间创建动画同步。你可以把它想象成一个魔法通道，让不同的视图共享相同的几何属性，从而实现流畅的过渡效果。使用 <code>@Namespace</code>，你可以轻松创建令人惊艳的“魔法移动”动画。</p><h2 id="命名空间的定义与作用-🪄" tabindex="-1">命名空间的定义与作用 🪄 <a class="header-anchor" href="#命名空间的定义与作用-🪄" aria-label="Permalink to &quot;命名空间的定义与作用 🪄&quot;">​</a></h2><p><code>@Namespace</code> 实际上是一个属性包装器，用于创建一个唯一的标识符。这个标识符可以被多个视图共享，从而建立起它们之间的联系。当你在这些视图之间进行切换时，SwiftUI 可以利用这个标识符来同步它们的几何属性，例如位置和大小。</p><ul><li><strong>唯一性</strong>: 每个 <code>@Namespace</code> 创建的标识符都是唯一的，确保动画的精确性。</li><li><strong>同步</strong>: 通过匹配相同的标识符，SwiftUI 能够同步不同视图的几何属性。</li><li><strong>动画</strong>: 这种同步是动画的基础，使得视图之间的过渡看起来自然而流畅。</li></ul><h2 id="如何使用-namespace-🛠️" tabindex="-1">如何使用 @Namespace 🛠️ <a class="header-anchor" href="#如何使用-namespace-🛠️" aria-label="Permalink to &quot;如何使用 @Namespace 🛠️&quot;">​</a></h2><p>使用 <code>@Namespace</code> 非常简单。首先，你需要在你的视图中声明一个 <code>@Namespace</code> 属性：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Namespace</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> namespace</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后，你可以使用 <code>matchedGeometryEffect(id:in:properties:anchor:isSource:)</code> 修饰符将视图与这个命名空间关联起来。<code>id</code> 参数是用于匹配视图的唯一标识符，<code>in</code> 参数指定了命名空间。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">matchedGeometryEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;uniqueID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: namespace)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="实例解析-简单的动画过渡-🌟" tabindex="-1">实例解析：简单的动画过渡 🌟 <a class="header-anchor" href="#实例解析-简单的动画过渡-🌟" aria-label="Permalink to &quot;实例解析：简单的动画过渡 🌟&quot;">​</a></h2><p>让我们通过一个简单的例子来理解 <code>@Namespace</code> 的用法。假设你有一个列表，点击列表项后，该项会放大并移动到屏幕的中央。</p><ol><li><strong>定义命名空间</strong>: 在你的视图中，首先定义一个 <code>@Namespace</code> 属性。</li><li><strong>关联视图</strong>: 使用 <code>matchedGeometryEffect</code> 将列表项和放大后的视图与同一个命名空间关联起来，并赋予它们相同的 <code>id</code>。</li><li><strong>状态切换</strong>: 当用户点击列表项时，切换视图的状态，触发动画。</li></ol><p>通过以上步骤，你可以看到列表项平滑地放大并移动到屏幕中央，这就是 <code>@Namespace</code> 的魔力！✨</p><h2 id="深入理解-matchedgeometryeffect-🧐" tabindex="-1">深入理解 matchedGeometryEffect 🧐 <a class="header-anchor" href="#深入理解-matchedgeometryeffect-🧐" aria-label="Permalink to &quot;深入理解 matchedGeometryEffect 🧐&quot;">​</a></h2><p><code>matchedGeometryEffect</code> 是实现动画效果的关键。它不仅可以将视图与命名空间关联起来，还可以指定需要同步的几何属性。</p><ul><li><strong>properties</strong>: 你可以选择同步哪些属性，例如 <code>.frame</code>, <code>.bounds</code>, <code>.position</code> 等。</li><li><strong>anchor</strong>: 你可以指定动画的锚点，例如 <code>.topLeading</code>, <code>.center</code> 等。</li><li><strong>isSource</strong>: 你可以控制哪个视图是动画的源头。</li></ul><p>通过灵活配置这些参数，你可以实现各种各样的动画效果。🎉</p>',19)]))}const k=a(o,[["render",n]]);export{m as __pageData,k as default};
