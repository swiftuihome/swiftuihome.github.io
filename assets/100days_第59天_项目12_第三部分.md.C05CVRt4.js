import{_ as l,c as e,o as i,ag as t}from"./chunks/framework.Bw-5EFTY.js";const f=JSON.parse('{"title":"第59天 项目12 第三部分","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第59天_项目12_第三部分.md","filePath":"100days/第59天_项目12_第三部分.md"}'),o={name:"100days/第59天_项目12_第三部分.md"};function d(p,a,c,r,s,u){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="第59天-项目12-第三部分" tabindex="-1">第59天 项目12 第三部分 <a class="header-anchor" href="#第59天-项目12-第三部分" aria-label="Permalink to &quot;第59天 项目12 第三部分&quot;">​</a></h1><p>你准备好迎接更多挑战了吗？</p><p>美国创作歌手兼词曲创作人克里斯蒂娜·格里米曾说过：“人并非生来强大；人们是在一次次遭遇困境、学会不逃避的过程中，一点点变得更强大的。” 优秀的程序员亦是如此：并非在埋头读书一年后，就会有某种神奇的转变开关被触发，相反，随着你不断面对并解决难度越来越高的问题，你的技能会慢慢提升。</p><p>我一直鼓励你攻克这些问题，因为亲自编写代码、找到属于自己的解决方案，这一点至关重要。起初，你常常会遇到“空白页综合征”——茫然地盯着屏幕，不知道从何下手。但这很正常，事实上，这种情况是意料之中的。练习得越多，你独立找到解决方案的能力就会越强，而今天就是朝着这个目标迈进的又一步。</p><p>今天，你需要完成第12个项目的总结章节，完成相关复习，然后攻克该项目的所有三个挑战。</p><ul><li>SwiftData：总结</li><li>第12个项目复习：SwiftData</li></ul><h2 id="swiftdata-总结" tabindex="-1">SwiftData：总结 <a class="header-anchor" href="#swiftdata-总结" aria-label="Permalink to &quot;SwiftData：总结&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月27日</p><p>虽然我们对SwiftData的了解还只是皮毛，但你已经见识到了它如何通过相对简单的代码实现数据的添加、删除、排序、筛选等功能。诚然，Swift中的某些部分（例如<code>#Predicate</code>）可能需要花些时间才能熟练掌握，但只要你足够细心，就不会有问题。</p><p>SwiftData最重要的特点或许在于，它能确保在所有苹果平台的所有应用中都可使用。这意味着无论你的需求是什么，都可以使用它：可能是用于保存重要数据，也可能只是用于缓存下载的内容；无论哪种情况，SwiftData都能出色地帮你管理这些数据。</p><h2 id="复习所学内容" tabindex="-1">复习所学内容 <a class="header-anchor" href="#复习所学内容" aria-label="Permalink to &quot;复习所学内容&quot;">​</a></h2><p>任何人都能看完一门教程，但要记住所学的知识，还需要付出实际的努力。我的职责是确保你能从这些教程中收获尽可能多的知识，完成后面的练习题可以帮助你检验自己的学习成果。</p><h2 id="挑战" tabindex="-1">挑战 <a class="header-anchor" href="#挑战" aria-label="Permalink to &quot;挑战&quot;">​</a></h2><p>学习编程最好的方法之一就是尽可能多地亲自编写代码，因此我为你准备了三种扩展本应用的方式，确保你能完全理解其中的原理。</p><p>这三个挑战都与你要升级的第7个项目——iExpense有关：</p><ol><li>首先，将该项目升级为使用SwiftData。</li><li>添加可自定义的排序选项：按名称排序或按金额排序。</li><li>添加筛选选项，以显示所有支出、仅个人支出或仅商务支出。</li></ol><h2 id="【练习题】swiftdata" tabindex="-1">【练习题】SwiftData <a class="header-anchor" href="#【练习题】swiftdata" aria-label="Permalink to &quot;【练习题】SwiftData&quot;">​</a></h2><p>问题1/12：以下哪些陈述是正确的？</p><ul><li>选项1：模型不会自动保存，除非我们专门进行保存操作。</li><li>选项2：SwiftData可在所有苹果平台上使用。</li></ul><p>问题2/12：以下哪些陈述是正确的？</p><ul><li>选项1：默认的关系删除规则是<code>.nullify</code>。</li><li>选项2：使用<code>modelContainer(for:)</code>修饰符时，必须列出所有使用的模型类型。</li></ul><p>问题3/12：以下哪些陈述是正确的？</p><ul><li>选项1：级联删除（Cascade deletes）有助于确保当父对象被删除时，关联的对象不会变成无主对象（left floating around）。</li><li>选项2：与CloudKit同步数据意味着无法使用任何SwiftData关系。</li></ul><p>问题4/12：以下哪些陈述是正确的？</p><ul><li>选项1：可以使用<code>#Predicate</code>筛选获取请求（fetch request）。</li><li>选项2：可以使用<code>SortDescriptor</code>筛选获取请求（fetch request）。</li></ul><p>问题5/12：以下哪些陈述是正确的？</p><ul><li>选项1：<code>Date.distantPast</code>指的是上周二。</li><li>选项2：SwiftData模型会自动遵循<code>Identifiable</code>协议。</li></ul><p>问题6/12：以下哪些陈述是正确的？</p><ul><li>选项1：SwiftData可以自动处理小型数据迁移。</li><li>选项2：定义SwiftData模型之间的关系时，必须始终使用<code>@Relationship</code>。</li></ul><p>问题7/12：以下哪些陈述是正确的？</p><ul><li>选项1：在SwiftData中，所有属性都必须是可选的（optional）。</li><li>选项2：<code>@Model</code>基于与<code>@Observable</code>相同的观察系统构建。</li></ul><p>问题8/12：以下哪些陈述是正确的？</p><ul><li>选项1：CloudKit同步需要苹果开发者账号。</li><li>选项2：SwiftData类只有在用于关系中时，才需要使用<code>@Model</code>。</li></ul><p>问题9/12：以下哪些陈述是正确的？</p><ul><li>选项1：CloudKit同步要求所有模型属性要么是可选的，要么有默认值。</li><li>选项2：关系（Relationships）指的是一个模型对象链接到另一个模型对象。</li></ul><p>问题10/12：以下哪些陈述是正确的？</p><ul><li>选项1：<code>@Bindable</code>与SwiftData对象不兼容。</li><li>选项2：动态排序可通过将值传递到子视图的初始化器中来实现。</li></ul><p>问题11/12：以下哪些陈述是正确的？</p><ul><li>选项1：可以通过调用<code>modelContext.delete(model: SomeType.self)</code>删除某一模型类型的所有实例。</li><li>选项2：<code>@Model</code>是一个属性包装器（property wrapper）。</li></ul><p>问题12/12：以下哪些陈述是正确的？</p><ul><li>选项1：<code>contains()</code>方法使谓词（predicates）区分大小写。</li><li>选项2：可以在<code>#Predicate</code>宏中放入任何类型的Swift代码。</li></ul>',41)]))}const _=l(o,[["render",d]]);export{f as __pageData,_ as default};
