import{_ as a,c as e,o as i,ag as t}from"./chunks/framework.Bw-5EFTY.js";const o=JSON.parse('{"title":"@StateObject 与 @ObservedObject 的关键区别 🧐","description":"","frontmatter":{},"headers":[],"relativePath":"lifecycle/7.3_@StateObject与@ObservedObject的关键区别.md","filePath":"lifecycle/7.3_@StateObject与@ObservedObject的关键区别.md"}'),n={name:"lifecycle/7.3_@StateObject与@ObservedObject的关键区别.md"};function l(p,s,h,r,c,k){return i(),e("div",null,s[0]||(s[0]=[t(`<h1 id="stateobject-与-observedobject-的关键区别-🧐" tabindex="-1">@StateObject 与 @ObservedObject 的关键区别 🧐 <a class="header-anchor" href="#stateobject-与-observedobject-的关键区别-🧐" aria-label="Permalink to &quot;@StateObject 与 @ObservedObject 的关键区别 🧐&quot;">​</a></h1><blockquote><p>在 SwiftUI 中，<code>@StateObject</code> 和 <code>@ObservedObject</code> 都用于管理引用类型的状态，但它们在生命周期管理上有着重要的区别。理解这些差异对于构建健壮的 SwiftUI 应用至关重要。让我们一起深入了解吧！🚀</p></blockquote><h2 id="生命周期管理的不同之处-🕰️" tabindex="-1">生命周期管理的不同之处 🕰️ <a class="header-anchor" href="#生命周期管理的不同之处-🕰️" aria-label="Permalink to &quot;生命周期管理的不同之处 🕰️&quot;">​</a></h2><p><code>@StateObject</code> 负责<strong>创建</strong>和<strong>持有</strong>其管理的对象。这意味着，当视图首次出现时，<code>@StateObject</code> 会初始化对象，并在视图的整个生命周期内保持该对象的存在。即使视图被重新绘制，<code>@StateObject</code> 管理的对象也不会被重新创建。这确保了数据的持久性和一致性。</p><p><code>@ObservedObject</code> 则不同，它<strong>仅仅是观察</strong>一个已经存在的对象，并不负责创建或持有该对象。因此，当视图被重新绘制时，<code>@ObservedObject</code> 观察的对象可能会被重新创建或替换。这可能导致数据丢失或意外的行为。</p><h2 id="何时使用-stateobject-🤔" tabindex="-1">何时使用 @StateObject 🤔 <a class="header-anchor" href="#何时使用-stateobject-🤔" aria-label="Permalink to &quot;何时使用 @StateObject 🤔&quot;">​</a></h2><p>你应该在以下情况下使用 <code>@StateObject</code>：</p><ol><li><strong>视图是对象数据的唯一来源</strong>：当视图需要拥有并管理某个对象的状态时，<code>@StateObject</code> 是最佳选择。</li><li><strong>确保对象在视图的整个生命周期内存在</strong>：如果你希望对象在视图的整个生命周期内保持不变，即使视图被重新绘制，那么 <code>@StateObject</code> 可以保证这一点。</li><li><strong>避免不必要的对象重新创建</strong>：使用 <code>@StateObject</code> 可以避免在视图重新绘制时重复创建对象，从而提高性能。</li></ol><h2 id="何时使用-observedobject-🧐" tabindex="-1">何时使用 @ObservedObject 🧐 <a class="header-anchor" href="#何时使用-observedobject-🧐" aria-label="Permalink to &quot;何时使用 @ObservedObject 🧐&quot;">​</a></h2><p>以下情况适合使用 <code>@ObservedObject</code>：</p><ol><li><strong>对象数据由外部提供</strong>：当对象数据来自其他视图或外部源时，<code>@ObservedObject</code> 可以用来观察这些数据。</li><li><strong>对象生命周期由外部控制</strong>：如果对象的生命周期由其他组件或系统管理，<code>@ObservedObject</code> 可以用来观察对象的变化，而无需关心对象的创建和销毁。</li><li><strong>多个视图共享同一个对象</strong>：<code>@ObservedObject</code> 允许不同的视图观察同一个对象，从而实现数据共享和同步。</li></ol><h2 id="示例代码对比-💻" tabindex="-1">示例代码对比 💻 <a class="header-anchor" href="#示例代码对比-💻" aria-label="Permalink to &quot;示例代码对比 💻&quot;">​</a></h2><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 @StateObject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @StateObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建并持有 MyData 对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(myData.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 @ObservedObject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @ObservedObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myData: MyData </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察外部提供的 MyData 对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(myData.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在这个例子中，<code>ContentView</code> 使用 <code>@StateObject</code> 创建并持有 <code>MyData</code> 对象，而 <code>MyView</code> 使用 <code>@ObservedObject</code> 观察外部提供的 <code>MyData</code> 对象。</p><p>总而言之，<code>@StateObject</code> 负责创建和持有对象，而 <code>@ObservedObject</code> 仅仅是观察对象。选择哪个取决于你的具体需求和对象数据的来源。希望这些解释能帮助你更好地理解它们之间的区别！🎉</p>`,15)]))}const b=a(n,[["render",l]]);export{o as __pageData,b as default};
