import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.Bw-5EFTY.js";const o=JSON.parse('{"title":"通过函数和@Published属性进行交互","description":"","frontmatter":{},"headers":[],"relativePath":"refactor/13.4_通过函数和`@Published`属性进行交互.md","filePath":"refactor/13.4_通过函数和`@Published`属性进行交互.md"}'),l={name:"refactor/13.4_通过函数和`@Published`属性进行交互.md"};function p(t,s,h,d,r,k){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="通过函数和-published属性进行交互" tabindex="-1">通过函数和<code>@Published</code>属性进行交互 <a class="header-anchor" href="#通过函数和-published属性进行交互" aria-label="Permalink to &quot;通过函数和\`@Published\`属性进行交互&quot;">​</a></h1><p>在 SwiftUI 中，<code>ViewModel</code> 通过函数和 <code>@Published</code> 属性与 <code>View</code> 进行交互，这是一种非常棒的方式来保持代码的清晰和可维护性！🎉 让我们深入了解一下。</p><h2 id="published-属性-状态的广播员" tabindex="-1"><code>@Published</code> 属性：状态的广播员 <a class="header-anchor" href="#published-属性-状态的广播员" aria-label="Permalink to &quot;\`@Published\` 属性：状态的广播员&quot;">​</a></h2><p><code>@Published</code> 是一个属性包装器，它来自 Combine 框架。当你使用 <code>@Published</code> 标记 <code>ViewModel</code> 中的属性时，每当该属性的值发生变化，它都会自动通知所有监听者。这就像一个广播员，告诉大家：“嘿，我更新了！” 📢</p><p>例如：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyViewModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ObservableObject </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @Published</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这个例子中，<code>counter</code> 是一个 <code>@Published</code> 属性。任何观察 <code>MyViewModel</code> 的 <code>View</code> 都会在 <code>counter</code> 改变时自动更新。</p><h2 id="函数-行为的触发器" tabindex="-1">函数：行为的触发器 <a class="header-anchor" href="#函数-行为的触发器" aria-label="Permalink to &quot;函数：行为的触发器&quot;">​</a></h2><p>函数是 <code>ViewModel</code> 中定义行为的主要方式。<code>View</code> 可以调用 <code>ViewModel</code> 中的函数来触发状态的改变。这使得 <code>View</code> 可以专注于展示数据，而将业务逻辑委托给 <code>ViewModel</code>。</p><p>例如：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyViewModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ObservableObject </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @Published</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> incrementCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在这个例子中，<code>incrementCounter()</code> 函数会增加 <code>counter</code> 的值。<code>View</code> 可以调用这个函数来增加计数器。</p><h2 id="在-view-中使用函数和-published" tabindex="-1">在 View 中使用函数和 <code>@Published</code> <a class="header-anchor" href="#在-view-中使用函数和-published" aria-label="Permalink to &quot;在 View 中使用函数和 \`@Published\`&quot;">​</a></h2><p>在 <code>View</code> 中，你可以使用 <code>@ObservedObject</code> 或 <code>@StateObject</code> 来观察 <code>ViewModel</code>。然后，你可以通过绑定到 <code>@Published</code> 属性来显示数据，并通过调用函数来触发行为。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @ObservedObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyViewModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        VStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Counter: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(viewModel.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">counter</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Increment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                viewModel.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">incrementCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在这个例子中，<code>Text</code> 视图绑定到 <code>viewModel.counter</code>，所以每当 <code>counter</code> 的值改变，<code>Text</code> 视图都会自动更新。<code>Button</code> 调用 <code>viewModel.incrementCounter()</code> 函数，从而改变 <code>counter</code> 的值。</p><h2 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h2><ul><li><strong>清晰的分离:</strong> 状态和行为被封装在 <code>ViewModel</code> 中，<code>View</code> 只负责展示。</li><li><strong>可测试性:</strong> <code>ViewModel</code> 可以独立于 <code>View</code> 进行测试。</li><li><strong>可维护性:</strong> 代码更易于理解和修改。</li></ul><p>通过函数和 <code>@Published</code> 属性进行交互，你可以构建出更加健壮和可维护的 SwiftUI 应用！💪 记住，良好的架构是成功的关键！</p>`,19)]))}const E=i(l,[["render",p]]);export{o as __pageData,E as default};
