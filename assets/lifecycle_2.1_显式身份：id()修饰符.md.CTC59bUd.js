import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.ymCRTBvy.js";const o=JSON.parse('{"title":"显式身份：id()修饰符","description":"","frontmatter":{},"headers":[],"relativePath":"lifecycle/2.1_显式身份：id()修饰符.md","filePath":"lifecycle/2.1_显式身份：id()修饰符.md"}'),l={name:"lifecycle/2.1_显式身份：id()修饰符.md"};function p(t,s,h,d,k,r){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="显式身份-id-修饰符" tabindex="-1">显式身份：id()修饰符 <a class="header-anchor" href="#显式身份-id-修饰符" aria-label="Permalink to &quot;显式身份：id()修饰符&quot;">​</a></h1><blockquote><p>在 SwiftUI 的世界里，视图的身份至关重要！它决定了 SwiftUI 如何管理和更新你的界面。<code>id()</code> 修饰符就像一个神奇的身份标签，让你能够显式地控制视图的身份。让我们一起深入了解它吧！🚀</p></blockquote><h2 id="为什么需要显式身份" tabindex="-1">为什么需要显式身份？ <a class="header-anchor" href="#为什么需要显式身份" aria-label="Permalink to &quot;为什么需要显式身份？&quot;">​</a></h2><p>SwiftUI 默认会根据视图的结构来推断其身份。但有时，这种推断可能不准确，导致视图不必要的销毁和重建。想象一下，你有一个列表，里面的数据项顺序发生了变化。如果没有显式身份，SwiftUI 可能会认为所有视图都发生了改变，从而重新渲染整个列表，这会影响性能！😱</p><p>显式身份可以解决这个问题。通过 <code>id()</code> 修饰符，你可以为每个视图指定一个唯一的标识符。这样，即使视图的结构发生了变化，SwiftUI 也能正确地识别它们，并只更新真正需要更新的部分。</p><h2 id="如何使用-id-修饰符" tabindex="-1">如何使用 <code>id()</code> 修饰符？ <a class="header-anchor" href="#如何使用-id-修饰符" aria-label="Permalink to &quot;如何使用 \`id()\` 修饰符？&quot;">​</a></h2><p>使用 <code>id()</code> 非常简单！你只需要将它添加到你的视图上，并传入一个符合 <code>Hashable</code> 协议的值作为标识符。这个值可以是任何类型，比如字符串、整数，甚至是自定义的结构体或枚举。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item: MyItem</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.id) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 item.id 作为视图的身份</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子中，我们使用 <code>item.id</code> 作为 <code>Text</code> 视图的身份。确保 <code>MyItem</code> 结构体或类有一个 <code>id</code> 属性，并且这个属性是唯一的。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Identifiable </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id: UUID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UUID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>UUID()</code> 可以生成一个全局唯一的标识符。</li><li>确保你的 <code>id</code> 是稳定的，不会在视图的生命周期内发生变化。</li></ul><h2 id="id-的威力-列表的优化" tabindex="-1"><code>id()</code> 的威力：列表的优化 <a class="header-anchor" href="#id-的威力-列表的优化" aria-label="Permalink to &quot;\`id()\` 的威力：列表的优化&quot;">​</a></h2><p><code>id()</code> 在处理动态列表时尤其有用。假设你有一个可编辑的列表，用户可以添加、删除或重新排序项目。通过为每个列表项指定一个唯一的 <code>id</code>，你可以确保 SwiftUI 只更新那些真正发生改变的项，而不是重新渲染整个列表。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(items) { item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item.id) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 确保每个列表项都有唯一的 id</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用 <code>id()</code> 可以显著提高列表的性能，尤其是在处理大量数据时。🎉</p><p>总而言之，<code>id()</code> 修饰符是 SwiftUI 中一个强大的工具，可以让你更好地控制视图的身份和生命周期。通过显式地指定视图的身份，你可以优化你的应用，提高性能，并确保用户体验的流畅性。记住，为你的视图赋予一个独特的身份，让 SwiftUI 更好地理解它们！👍</p>`,16)]))}const E=i(l,[["render",p]]);export{o as __pageData,E as default};
