import{_ as s,c as a,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"管理viewWillDisappear和viewDidDisappear","description":"","frontmatter":{},"headers":[],"relativePath":"swift/uikit/advanced/2.4_管理viewWillDisappear和viewDidDisappear.md","filePath":"swift/uikit/advanced/2.4_管理viewWillDisappear和viewDidDisappear.md"}'),p={name:"swift/uikit/advanced/2.4_管理viewWillDisappear和viewDidDisappear.md"};function l(r,i,t,h,d,k){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="管理viewwilldisappear和viewdiddisappear" tabindex="-1">管理viewWillDisappear和viewDidDisappear <a class="header-anchor" href="#管理viewwilldisappear和viewdiddisappear" aria-label="Permalink to &quot;管理viewWillDisappear和viewDidDisappear&quot;">​</a></h1><h2 id="理解视图即将消失的时刻" tabindex="-1">理解视图即将消失的时刻 <a class="header-anchor" href="#理解视图即将消失的时刻" aria-label="Permalink to &quot;理解视图即将消失的时刻&quot;">​</a></h2><p>当用户从一个视图控制器导航离开时，<code>viewWillDisappear</code> 方法就会被调用。这是一个绝佳的时机来执行一些清理工作或保存状态。想象一下，你正在填写一个表单，突然需要返回上一个页面，你肯定希望你的输入不会丢失！ 📝</p><p>这个方法在视图从屏幕上移除<strong>之前</strong>被调用。它为你提供了一个宝贵的机会，可以在视图完全消失前进行最后的调整。例如，你可以停止正在进行的动画，或者取消网络请求，避免不必要的资源消耗。</p><h2 id="视图消失后的处理" tabindex="-1">视图消失后的处理 <a class="header-anchor" href="#视图消失后的处理" aria-label="Permalink to &quot;视图消失后的处理&quot;">​</a></h2><p>紧接着 <code>viewWillDisappear</code>，当视图控制器完全从屏幕上移除并不再可见时，<code>viewDidDisappear</code> 方法就会被触发。这是进行更彻底清理的理想场所。你可以在这里释放那些不再需要的内存资源。</p><p>例如，如果你在 <code>viewDidAppear</code> 中注册了通知观察者，那么在 <code>viewDidDisappear</code> 中取消注册就显得尤为重要。这能有效防止内存泄漏，确保你的应用运行流畅。 🚀</p><h2 id="实际应用场景与最佳实践" tabindex="-1">实际应用场景与最佳实践 <a class="header-anchor" href="#实际应用场景与最佳实践" aria-label="Permalink to &quot;实际应用场景与最佳实践&quot;">​</a></h2><p>管理 <code>viewWillDisappear</code> 和 <code>viewDidDisappear</code> 是构建高效、无内存泄漏应用的关键。以下是一些常见的应用场景：</p><ul><li><strong>停止媒体播放</strong>：当用户离开一个包含视频或音频播放器的视图时，你可以在 <code>viewWillDisappear</code> 中暂停或停止播放。</li><li><strong>保存用户数据</strong>：在视图消失前，将用户在当前视图中输入的数据保存到本地存储或服务器。</li><li><strong>取消网络请求</strong>：如果视图正在进行网络请求，可以在 <code>viewWillDisappear</code> 中取消它们，避免在视图不再需要数据时继续消耗带宽。</li></ul><h2 id="避免常见的陷阱" tabindex="-1">避免常见的陷阱 <a class="header-anchor" href="#避免常见的陷阱" aria-label="Permalink to &quot;避免常见的陷阱&quot;">​</a></h2><p>在使用这两个方法时，有一些常见的陷阱需要注意。首先，不要在 <code>viewWillDisappear</code> 中执行耗时操作，因为它会阻塞视图的消失过程，导致用户界面卡顿。 🐢</p><p>其次，确保在 <code>viewDidDisappear</code> 中释放所有在 <code>viewDidAppear</code> 中分配的资源。例如，如果你在 <code>viewDidAppear</code> 中启动了一个计时器，那么在 <code>viewDidDisappear</code> 中停止并销毁它至关重要。</p><h2 id="示例代码片段" tabindex="-1">示例代码片段 <a class="header-anchor" href="#示例代码片段" aria-label="Permalink to &quot;示例代码片段&quot;">​</a></h2><p>让我们看一个简单的例子，展示如何在实际项目中使用这些方法：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> viewWillDisappear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animated: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viewWillDisappear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animated)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;视图即将消失！准备保存数据或停止动画。&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 示例：停止一个动画</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    myAnimationLayer.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">removeAllAnimations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> viewDidDisappear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animated: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viewDidDisappear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animated)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;视图已经消失！可以释放不再需要的资源了。&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 示例：移除通知观察者</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    NotificationCenter.default.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">removeObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>通过精心管理这些生命周期方法，你将能够构建出响应迅速、资源高效的iOS应用。这不仅提升了用户体验，也展现了你作为开发者的专业素养！ 🌟 记住，细致的资源管理是优秀应用的基础。</p>`,17)]))}const E=s(p,[["render",l]]);export{c as __pageData,E as default};
