import{_ as t,c as e,o,ag as i}from"./chunks/framework.ymCRTBvy.js";const h=JSON.parse('{"title":"NavigationStack中视图的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"lifecycle/12.1_NavigationStack中视图的生命周期.md","filePath":"lifecycle/12.1_NavigationStack中视图的生命周期.md"}'),c={name:"lifecycle/12.1_NavigationStack中视图的生命周期.md"};function n(d,a,r,l,s,_){return o(),e("div",null,a[0]||(a[0]=[i('<h1 id="navigationstack中视图的生命周期" tabindex="-1">NavigationStack中视图的生命周期 <a class="header-anchor" href="#navigationstack中视图的生命周期" aria-label="Permalink to &quot;NavigationStack中视图的生命周期&quot;">​</a></h1><h2 id="navigationstack的视图创建" tabindex="-1">NavigationStack的视图创建 <a class="header-anchor" href="#navigationstack的视图创建" aria-label="Permalink to &quot;NavigationStack的视图创建&quot;">​</a></h2><p>在 <code>NavigationStack</code> 中，视图的生命周期管理非常精妙。 当你将一个视图推入导航堆栈时，SwiftUI 会立即创建并初始化这个新视图。 🚀 这意味着即使它还没有完全显示在屏幕上，视图的 <code>body</code> 属性也已经被计算。</p><p>这种预先创建的机制确保了流畅的过渡动画。 你会发现，视图的 <code>onAppear</code> 修饰符会在视图即将显示时被调用。</p><h2 id="视图的更新与重用" tabindex="-1">视图的更新与重用 <a class="header-anchor" href="#视图的更新与重用" aria-label="Permalink to &quot;视图的更新与重用&quot;">​</a></h2><p><code>NavigationStack</code> 中的视图更新机制非常高效。 当视图的状态发生变化时，SwiftUI 会重新计算 <code>body</code>。 这并不会销毁并重新创建整个视图，而是智能地更新受影响的部分。</p><p>例如，如果你在导航到的视图中改变了一个 <code>@State</code> 变量，只有依赖于该变量的视图部分会重新渲染。 这种优化显著提升了应用性能。 🌟</p><h2 id="视图的销毁时机" tabindex="-1">视图的销毁时机 <a class="header-anchor" href="#视图的销毁时机" aria-label="Permalink to &quot;视图的销毁时机&quot;">​</a></h2><p>当一个视图从 <code>NavigationStack</code> 中弹出时，SwiftUI 会负责销毁它。 这通常发生在用户点击返回按钮，或者你通过编程方式弹出视图时。 视图的 <code>onDisappear</code> 修饰符会在视图从屏幕上移除时被调用。</p><p>这是一个清理资源的好时机，例如取消网络请求或停止计时器。 及时清理可以有效避免内存泄漏。 ♻️</p><h2 id="导航路径与视图生命周期" tabindex="-1">导航路径与视图生命周期 <a class="header-anchor" href="#导航路径与视图生命周期" aria-label="Permalink to &quot;导航路径与视图生命周期&quot;">​</a></h2><p><code>NavigationStack</code> 使用 <code>NavigationPath</code> 来管理导航历史。 每次你推入一个新视图，<code>NavigationPath</code> 都会更新。 这使得视图的生命周期与导航路径紧密关联。</p><ul><li><strong>推入视图</strong>: 新视图被创建并添加到视图层级。</li><li><strong>弹出视图</strong>: 视图从层级中移除并销毁。</li></ul><p>这种清晰的生命周期管理让开发者能够更好地控制视图行为。 掌握这些知识，你就能构建出更稳定、更高效的 SwiftUI 应用！ 💯</p>',14)]))}const g=t(c,[["render",n]]);export{h as __pageData,g as default};
