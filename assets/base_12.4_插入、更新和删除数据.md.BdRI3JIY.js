import{_ as a,c as t,o,ag as d}from"./chunks/framework.ymCRTBvy.js";const h=JSON.parse('{"title":"插入、更新和删除数据","description":"","frontmatter":{},"headers":[],"relativePath":"base/12.4_插入、更新和删除数据.md","filePath":"base/12.4_插入、更新和删除数据.md"}'),l={name:"base/12.4_插入、更新和删除数据.md"};function r(p,e,i,n,s,c){return o(),t("div",null,e[0]||(e[0]=[d('<h1 id="插入、更新和删除数据" tabindex="-1">插入、更新和删除数据 <a class="header-anchor" href="#插入、更新和删除数据" aria-label="Permalink to &quot;插入、更新和删除数据&quot;">​</a></h1><h2 id="插入数据-🚀" tabindex="-1">插入数据 🚀 <a class="header-anchor" href="#插入数据-🚀" aria-label="Permalink to &quot;插入数据 🚀&quot;">​</a></h2><p>在SwiftData中插入数据非常直接。 你会发现它比以往任何时候都更容易管理你的模型对象。 想象一下，你正在构建一个任务管理应用，你需要添加新的任务。</p><p>首先，你需要创建一个新的模型实例。 比如，<code>let newTask = Task(name: &quot;学习SwiftData&quot;, isCompleted: false)</code>。 接下来，你需要访问模型的上下文。</p><p>你可以通过 <code>@Environment(\\.modelContext) var modelContext</code> 来获取它。 然后，只需调用 <code>modelContext.insert(newTask)</code>。 瞧！你的新任务就成功插入了。</p><p>这个过程非常高效，通常在几毫秒内完成，即使是处理大量数据。 事实上，超过95%的插入操作在10毫秒内完成。</p><h2 id="更新数据-✨" tabindex="-1">更新数据 ✨ <a class="header-anchor" href="#更新数据-✨" aria-label="Permalink to &quot;更新数据 ✨&quot;">​</a></h2><p>更新现有数据同样简单。 假设你有一个任务，现在它已经完成了。 你需要找到这个任务对象。</p><p>一旦你有了任务对象，比如 <code>let taskToUpdate = fetchedTasks.first</code>，你就可以直接修改它的属性。 例如，<code>taskToUpdate.isCompleted = true</code>。</p><p>SwiftData会自动检测到这些变化。 你不需要调用任何特定的“更新”方法。 这种自动追踪机制极大地简化了你的代码。</p><p>它确保了数据的一致性，并且减少了手动同步的需要。 这种无缝的更新体验真是太棒了！</p><h2 id="删除数据-🗑️" tabindex="-1">删除数据 🗑️ <a class="header-anchor" href="#删除数据-🗑️" aria-label="Permalink to &quot;删除数据 🗑️&quot;">​</a></h2><p>删除数据也毫不费力。 当你不再需要某个任务时，你可以轻松地将其从数据库中移除。</p><p>你需要获取到你想要删除的模型对象。 比如，你可能通过查询获取到了一系列任务。</p><ul><li>找到要删除的对象。</li><li>调用 <code>modelContext.delete(objectToDelete)</code>。</li></ul><p>例如，<code>modelContext.delete(taskToDelete)</code>。 SwiftData会负责处理所有的清理工作。</p><p>这包括从持久化存储中移除数据，并更新任何相关的视图。 这种简洁的API设计让你能够专注于构建出色的功能。</p><h2 id="持久化更改-💾" tabindex="-1">持久化更改 💾 <a class="header-anchor" href="#持久化更改-💾" aria-label="Permalink to &quot;持久化更改 💾&quot;">​</a></h2><p>虽然插入、更新和删除操作会自动被SwiftData追踪，但你可能需要手动保存更改。 这在某些特定场景下非常有用。</p><p>例如，如果你想确保在应用退出前所有更改都已保存。 你可以调用 <code>try modelContext.save()</code>。</p><p>这是一个同步操作，所以请确保在适当的时机调用它。 在大多数情况下，SwiftData会为你自动处理保存。</p><p>但了解如何手动触发保存，会让你在开发过程中拥有更大的控制权。 这是一个强大的工具，可以让你构建出更健壮的应用。</p>',22)]))}const m=a(l,[["render",r]]);export{h as __pageData,m as default};
