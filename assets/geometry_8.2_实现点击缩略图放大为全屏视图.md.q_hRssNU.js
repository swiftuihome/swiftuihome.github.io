import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.ymCRTBvy.js";const E=JSON.parse('{"title":"实现点击缩略图放大为全屏视图","description":"","frontmatter":{},"headers":[],"relativePath":"geometry/8.2_实现点击缩略图放大为全屏视图.md","filePath":"geometry/8.2_实现点击缩略图放大为全屏视图.md"}'),l={name:"geometry/8.2_实现点击缩略图放大为全屏视图.md"};function p(t,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="实现点击缩略图放大为全屏视图" tabindex="-1">实现点击缩略图放大为全屏视图 <a class="header-anchor" href="#实现点击缩略图放大为全屏视图" aria-label="Permalink to &quot;实现点击缩略图放大为全屏视图&quot;">​</a></h1><h2 id="响应式布局与视图状态" tabindex="-1">响应式布局与视图状态 <a class="header-anchor" href="#响应式布局与视图状态" aria-label="Permalink to &quot;响应式布局与视图状态&quot;">​</a></h2><p>在 SwiftUI 中，实现点击缩略图放大为全屏视图是一个非常酷炫的效果！✨ 你会发现这比你想象的要简单。关键在于管理视图的状态。当用户点击一张图片时，我们需要改变一个状态变量。这个变量会告诉我们的视图，现在应该显示全屏模式了。</p><p>例如，你可以使用 <code>@State</code> 属性包装器来声明一个布尔值。这个值将控制全屏视图的可见性。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isFullScreen: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> selectedImage: Image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当 <code>isFullScreen</code> 为 <code>true</code> 时，全屏视图就会出现。当它为 <code>false</code> 时，全屏视图就会消失。</p><h2 id="触发全屏显示" tabindex="-1">触发全屏显示 <a class="header-anchor" href="#触发全屏显示" aria-label="Permalink to &quot;触发全屏显示&quot;">​</a></h2><p>要实现点击缩略图触发全屏显示，你需要为每个缩略图添加一个手势识别器。最常用的就是 <code>onTapGesture</code>。当用户点击缩略图时，这个手势会执行一个动作。</p><p>在这个动作中，你会将 <code>isFullScreen</code> 设置为 <code>true</code>。同时，你还需要将当前被点击的图片赋值给 <code>selectedImage</code>。这样，全屏视图就知道要显示哪张图片了。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;thumbnail&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">resizable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scaledToFit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">onTapGesture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        selectedImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fullScreenImage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        isFullScreen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这种方法确保了只有在用户明确点击时，全屏视图才会被激活。</p><h2 id="构建全屏视图" tabindex="-1">构建全屏视图 <a class="header-anchor" href="#构建全屏视图" aria-label="Permalink to &quot;构建全屏视图&quot;">​</a></h2><p>全屏视图本身可以是一个简单的 <code>ZStack</code>。它包含你想要放大的图片。这个视图会根据 <code>isFullScreen</code> 的值条件性地显示。</p><p>你可以使用 <code>if</code> 语句来控制它的存在。当 <code>isFullScreen</code> 为 <code>true</code> 并且 <code>selectedImage</code> 不为空时，全屏视图就会被渲染。</p><ul><li><strong>背景叠加层</strong>: 通常，全屏视图会有一个半透明的背景。这能让用户知道他们进入了一个不同的模式。</li><li><strong>图片显示</strong>: 使用 <code>selectedImage</code> 来显示被选中的图片。确保它能够填充整个屏幕。</li><li><strong>关闭按钮</strong>: 提供一个方式让用户退出全屏模式。一个简单的点击手势就可以将 <code>isFullScreen</code> 设置回 <code>false</code>。</li></ul><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isFullScreen, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> image </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> selectedImage {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ZStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Color.black.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">opacity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">edgesIgnoringSafeArea</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.all)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">onTapGesture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                isFullScreen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                selectedImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        image</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">resizable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scaledToFit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="动画过渡的准备" tabindex="-1">动画过渡的准备 <a class="header-anchor" href="#动画过渡的准备" aria-label="Permalink to &quot;动画过渡的准备&quot;">​</a></h2><p>虽然本章不深入 <code>matchedGeometryEffect</code>，但理解其基础是关键。为了让缩略图到全屏视图的过渡看起来平滑，你需要为两个视图都准备好 <code>id</code> 和 <code>namespace</code>。</p><ul><li><strong>唯一标识符</strong>: 每个视图都需要一个唯一的标识符。</li><li><strong>命名空间</strong>: 所有的相关视图都必须共享同一个命名空间。</li></ul><p>这些是实现“魔法移动”效果的基石。通过这些步骤，你已经成功地为你的应用添加了一个引人注目的交互功能！🚀 这种用户体验的提升，无疑会大大增加用户的满意度。</p>`,20)]))}const o=i(l,[["render",p]]);export{E as __pageData,o as default};
