import{_ as e,c as i,o as t,ag as r}from"./chunks/framework.ymCRTBvy.js";const d=JSON.parse('{"title":"UIKit进阶：纯代码UI布局与动态交互","description":"","frontmatter":{},"headers":[],"relativePath":"swift/uikit/advanced/目录.md","filePath":"swift/uikit/advanced/目录.md"}'),o={name:"swift/uikit/advanced/目录.md"};function p(l,a,n,_,s,h){return t(),i("div",null,a[0]||(a[0]=[r('<h1 id="uikit进阶-纯代码ui布局与动态交互" tabindex="-1">UIKit进阶：纯代码UI布局与动态交互 <a class="header-anchor" href="#uikit进阶-纯代码ui布局与动态交互" aria-label="Permalink to &quot;UIKit进阶：纯代码UI布局与动态交互&quot;">​</a></h1><h2 id="第1章-告别storyboard-项目启动流程" tabindex="-1">第1章_告别Storyboard：项目启动流程 <a class="header-anchor" href="#第1章-告别storyboard-项目启动流程" aria-label="Permalink to &quot;第1章_告别Storyboard：项目启动流程&quot;">​</a></h2><p>1.1_删除项目中的Main.storyboard文件</p><p>1.2_清理Info.plist中的Storyboard相关配置</p><p>1.3_修改SceneDelegate设置window的根控制器</p><p>1.4_在AppDelegate中处理旧版iOS启动流程</p><h2 id="第2章-视图控制器生命周期与视图加载" tabindex="-1">第2章_视图控制器生命周期与视图加载 <a class="header-anchor" href="#第2章-视图控制器生命周期与视图加载" aria-label="Permalink to &quot;第2章_视图控制器生命周期与视图加载&quot;">​</a></h2><p>2.1_重写loadView方法以创建主视图</p><p>2.2_在viewDidLoad中进行视图的初始化配置</p><p>2.3_理解viewWillAppear和viewDidAppear的作用</p><p>2.4_管理viewWillDisappear和viewDidDisappear</p><h2 id="第3章-nslayoutconstraint基础" tabindex="-1">第3章_NSLayoutConstraint基础 <a class="header-anchor" href="#第3章-nslayoutconstraint基础" aria-label="Permalink to &quot;第3章_NSLayoutConstraint基础&quot;">​</a></h2><p>3.1_关闭translatesAutoresizingMaskIntoConstraints</p><p>3.2_使用NSLayoutConstraint初始化约束</p><p>3.3_批量激活与停用约束：activate和deactivate</p><p>3.4_理解约束的优先级（Priority）</p><h2 id="第4章-现代布局方法-layout-anchors" tabindex="-1">第4章_现代布局方法：Layout_Anchors <a class="header-anchor" href="#第4章-现代布局方法-layout-anchors" aria-label="Permalink to &quot;第4章_现代布局方法：Layout_Anchors&quot;">​</a></h2><p>4.1_使用leading或trailing或top或bottom锚点</p><p>4.2_使用width或height或centerX或centerY锚点</p><p>4.3_通过constraintEqualTo设置等值约束</p><p>4.4_使用multiplier和constant调整约束</p><h2 id="第5章-动态与复杂的约束管理" tabindex="-1">第5章_动态与复杂的约束管理 <a class="header-anchor" href="#第5章-动态与复杂的约束管理" aria-label="Permalink to &quot;第5章_动态与复杂的约束管理&quot;">​</a></h2><p>5.1_存储约束属性以便后续修改</p><p>5.2_在动画块中更新约束常量</p><p>5.3_根据不同尺寸类别（Size_Classes）切换约束</p><p>5.4_调试Auto_Layout约束冲突</p><h2 id="第6章-uicollectionview纯代码实践" tabindex="-1">第6章_UICollectionView纯代码实践 <a class="header-anchor" href="#第6章-uicollectionview纯代码实践" aria-label="Permalink to &quot;第6章_UICollectionView纯代码实践&quot;">​</a></h2><p>6.1_初始化UICollectionView和FlowLayout</p><p>6.2_注册自定义Cell和ReusableView类</p><p>6.3_实现DataSource和Delegate协议</p><p>6.4_通过代码处理Cell的选中与交互</p><h2 id="第7章-uitableview纯代码实践" tabindex="-1">第7章_UITableView纯代码实践 <a class="header-anchor" href="#第7章-uitableview纯代码实践" aria-label="Permalink to &quot;第7章_UITableView纯代码实践&quot;">​</a></h2><p>7.1_初始化UITableView并设置样式</p><p>7.2_注册自定义UITableViewCell类</p><p>7.3_实现UITableViewDataSource数据源方法</p><p>7.4_实现UITableViewDelegate代理方法</p><h2 id="第8章-uiscrollview与内容布局" tabindex="-1">第8章_UIScrollView与内容布局 <a class="header-anchor" href="#第8章-uiscrollview与内容布局" aria-label="Permalink to &quot;第8章_UIScrollView与内容布局&quot;">​</a></h2><p>8.1_创建UIScrollView并添加内容视图</p><p>8.2_使用Auto_Layout约束内容视图的尺寸</p><p>8.3_实现滚动和缩放功能</p><p>8.4_处理键盘遮挡UIScrollView内容</p><h2 id="第9章-创建可复用的自定义uiview" tabindex="-1">第9章_创建可复用的自定义UIView <a class="header-anchor" href="#第9章-创建可复用的自定义uiview" aria-label="Permalink to &quot;第9章_创建可复用的自定义UIView&quot;">​</a></h2><p>9.1_封装子视图和布局逻辑</p><p>9.2_通过自定义init方法传递参数</p><p>9.3_重写intrinsicContentSize提供固有尺寸</p><p>9.4_使用@IBDesignable和@IBInspectable预览</p><h2 id="第10章-core-graphics基础绘图" tabindex="-1">第10章_Core_Graphics基础绘图 <a class="header-anchor" href="#第10章-core-graphics基础绘图" aria-label="Permalink to &quot;第10章_Core_Graphics基础绘图&quot;">​</a></h2><p>10.1_重写draw(rect:)方法进行绘制</p><p>10.2_使用UIBezierPath绘制路径和形状</p><p>10.3_设置颜色、线宽和填充样式</p><p>10.4_绘制文本和图像</p><h2 id="第11章-calayer图层操作" tabindex="-1">第11章_CALayer图层操作 <a class="header-anchor" href="#第11章-calayer图层操作" aria-label="Permalink to &quot;第11章_CALayer图层操作&quot;">​</a></h2><p>11.1_设置圆角、边框和阴影</p><p>11.2_使用CAShapeLayer创建复杂形状图层</p><p>11.3_使用CAGradientLayer创建渐变效果</p><p>11.4_图层蒙版（Masking）的应用</p><h2 id="第12章-手势识别-gesture-recognizers" tabindex="-1">第12章_手势识别（Gesture_Recognizers） <a class="header-anchor" href="#第12章-手势识别-gesture-recognizers" aria-label="Permalink to &quot;第12章_手势识别（Gesture_Recognizers）&quot;">​</a></h2><p>12.1_添加点击（UITapGestureRecognizer）</p><p>12.2_添加滑动手势（UISwipeGestureRecognizer）</p><p>12.3_实现拖动（UIPanGestureRecognizer）</p><p>12.4_处理缩放与旋转手势</p><h2 id="第13章-uiview属性动画" tabindex="-1">第13章_UIView属性动画 <a class="header-anchor" href="#第13章-uiview属性动画" aria-label="Permalink to &quot;第13章_UIView属性动画&quot;">​</a></h2><p>13.1_使用UIView.animate进行基本动画</p><p>13.2_设置动画时长、延迟和选项</p><p>13.3_实现弹簧效果（Spring_Animations）</p><p>13.4_创建关键帧动画（Keyframe_Animations）</p><h2 id="第14章-转场动画与视图控制器切换" tabindex="-1">第14章_转场动画与视图控制器切换 <a class="header-anchor" href="#第14章-转场动画与视图控制器切换" aria-label="Permalink to &quot;第14章_转场动画与视图控制器切换&quot;">​</a></h2><p>14.1_实现自定义模态（Modal）转场</p><p>14.2_实现自定义导航控制器（Push或Pop）转场</p><p>14.3_遵循UIViewControllerAnimatedTransitioning协议</p><p>14.4_创建交互式转场（Interactive_Transitions）</p><h2 id="第15章-自定义容器视图控制器" tabindex="-1">第15章_自定义容器视图控制器 <a class="header-anchor" href="#第15章-自定义容器视图控制器" aria-label="Permalink to &quot;第15章_自定义容器视图控制器&quot;">​</a></h2><p>15.1_理解父子视图控制器关系</p><p>15.2_使用addChild和removeFromParent管理子VC</p><p>15.3_定义子视图控制器的视图frame</p><p>15.4_处理容器VC的转场逻辑</p><h2 id="第16章-数据驱动的ui更新" tabindex="-1">第16章_数据驱动的UI更新 <a class="header-anchor" href="#第16章-数据驱动的ui更新" aria-label="Permalink to &quot;第16章_数据驱动的UI更新&quot;">​</a></h2><p>16.1_设计ViewModel来驱动UI状态</p><p>16.2_使用属性观察者（didSet）更新视图</p><p>16.3_实现轻量级的绑定机制</p><p>16.4_分离数据处理与视图渲染逻辑</p><h2 id="第17章-组件化ui开发" tabindex="-1">第17章_组件化UI开发 <a class="header-anchor" href="#第17章-组件化ui开发" aria-label="Permalink to &quot;第17章_组件化UI开发&quot;">​</a></h2><p>17.1_将UI元素封装成独立的组件</p><p>17.2_定义清晰的组件API</p><p>17.3_通过组合组件构建复杂页面</p><p>17.4_管理组件间的通信</p>',86)]))}const u=e(o,[["render",p]]);export{d as __pageData,u as default};
