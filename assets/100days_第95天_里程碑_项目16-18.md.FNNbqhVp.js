import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const E=JSON.parse('{"title":"第95天 里程碑 项目 16-18","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第95天_里程碑_项目16-18.md","filePath":"100days/第95天_里程碑_项目16-18.md"}'),l={name:"100days/第95天_里程碑_项目16-18.md"};function p(t,s,h,k,d,r){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="第95天-里程碑-项目-16-18" tabindex="-1">第95天 里程碑 项目 16-18 <a class="header-anchor" href="#第95天-里程碑-项目-16-18" aria-label="Permalink to &quot;第95天 里程碑 项目 16-18&quot;">​</a></h1><p>完成了两个大型项目和另一个技术项目后，是时候停下来反思所学内容，更深入地探讨几个关键主题，然后迎接新的挑战了。这是你在这100天里的最后一个挑战，所以我特意挑选了一个灵活度高的任务——如果你愿意，30分钟就能完成，但你也可以根据自己的兴趣完成一些可选的额外任务。</p><p>这个挑战的好处在于，它为你提供了各种空间，可以按照自己的意愿开发应用，实现你认为最有趣或最有用的功能。核心在于，你有一块一块空白的画布，能否把它变成实实在在的作品全看你自己——你需要选择想做的内容，设计用户界面，修复自己遇到的漏洞，然后让应用准备就绪。</p><p>和往常一样，不要害怕犯错，因为犯错是很正常的事。正如罗杰·克劳福德曾经说过的：“生活中遇到挑战是不可避免的，但被打败却是可以选择的。”</p><p>今天你需要学习三个主题，其中一个就是你的挑战任务。</p><ul><li>所学内容</li><li>关键点</li><li>挑战任务</li></ul><p>注意：如果没有在指定日期完成挑战也不用担心——在之后的日子里，你会发现时不时会有一些空闲时间，所以挑战任务是可以在之后回头再完成的。</p><h2 id="所学内容" tabindex="-1">所学内容 <a class="header-anchor" href="#所学内容" aria-label="Permalink to &quot;所学内容&quot;">​</a></h2><p>最近我们完成了几个耗时较长的项目，这主要是因为你的SwiftUI技能确实有了很大提升——你已经远远超出基础水平了，所以现在能够处理更大的项目，解决更复杂的问题。我知道开发这些大型项目可能会让人觉得疲惫，但希望你回头看看自己构建的成果时能感到满意——你已经取得了巨大的进步！</p><p>在完成这些项目的过程中，你还学到了以下内容：</p><ul><li>使用<code>TabView</code>创建标签页。</li><li>利用Swift的<code>Result</code>类型返回成功或失败的结果。</li><li>控制图像插值。</li><li>为列表行添加滑动操作。</li><li>在<code>ContextMenu</code>中放置按钮。</li><li>使用UserNotifications框架创建本地通知。</li><li>通过Swift包依赖使用第三方代码。</li><li>如何创建动态二维码。</li><li>为SwiftUI视图附加自定义手势。</li><li>利用感官反馈让iPhone产生震动效果。</li><li>使用<code>allowsHitTesting()</code>禁用用户交互。</li><li>使用<code>Timer</code>重复触发事件。</li><li>跟踪应用在后台和前台之间切换时的场景状态变化。</li><li>支持色盲模式、减少动态效果等辅助功能。</li><li>SwiftUI的三步布局系统。</li><li>对齐方式、对齐指南以及自定义对齐指南。</li><li>使用<code>position()</code>修饰符绝对定位视图。</li><li>利用<code>GeometryReader</code>、<code>GeometryProxy</code>和<code>containerRelativeFrame()</code>制作特殊效果。</li></ul><p>而且你还构建了一些实际的应用来实践这些技能——这段时间确实很忙碌，希望你能为自己取得的成就感到自豪！</p><h2 id="关键点" tabindex="-1">关键点 <a class="header-anchor" href="#关键点" aria-label="Permalink to &quot;关键点&quot;">​</a></h2><p>在开始这个项目的挑战任务之前，我想更深入地探讨两个要点，确保你能完全理解它们：<code>map()</code>和<code>filter()</code>在更广泛的函数式编程领域中处于什么位置，以及Swift的<code>Result</code>类型。</p><h2 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-label="Permalink to &quot;函数式编程&quot;">​</a></h2><p>虽然我在我的《Pro Swift》一书中详细介绍了函数式编程，但在这里我还是想简单提一下，因为我们在第16个项目中简要使用过<code>map()</code>方法。这个方法的设计初衷是让我们明确“想要什么”，而不是“如何实现”，这两者都属于一种更广泛的编程方法，即“函数式编程”。</p><p>为了展示这种方法与另一种常见编程方法（命令式编程）的区别，我们来看下面这段代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> evens </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isMultiple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        evens.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这段代码创建了一个整数数组，逐个遍历数组中的元素，并将能被2整除的元素添加到一个名为<code>evens</code>的新数组中——我们需要详细说明整个过程应该如何执行。</p><p>这段代码易于阅读、易于编写，而且运行效果很好，但我们可以使用一种名为<code>filter()</code>的函数式编程方法，将其重写为：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> evens </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isMultiple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>现在，我们不需要详细说明过程应该如何执行，而是专注于“想要实现什么”：我们向<code>filter()</code>提供一个判断条件，剩下的工作就由它来完成。这意味着代码更简洁，这当然很棒，但除此之外，代码还在三个方面得到了改进：</p><ol><li>不再可能在循环中意外添加<code>break</code>语句——<code>filter()</code>总会处理数组中的每个元素，这种额外的简洁性让我们可以专注于判断条件本身。</li><li>除了提供闭包，我们还可以调用一个共享函数，这对代码复用非常有利。</li><li>最终得到的<code>evens</code>数组现在是常量，因此之后不会不小心修改它。</li></ol><p>代码更短总是好的，但写出更简洁、更易于复用且变量更少的代码会更好！</p><p>接受函数作为参数，或者返回函数作为结果的函数，被称为“高阶函数”，<code>map()</code>和<code>filter()</code>都是高阶函数的例子。Swift中还有很多类似的函数，其中<code>compactMap()</code>非常实用，它的作用如下：</p><ol><li>和<code>map()</code>一样，对数组中的每个元素执行一个转换函数。</li><li>解包转换函数返回的可选值，并将结果放入一个新数组中返回。</li><li>所有为<code>nil</code>的可选值都会被丢弃。</li></ol><p>因此，<code>map()</code>会创建一个与原数组元素数量相同的新数组，而<code>compactMap()</code>返回的数组元素数量可能与原数组相同，也可能更少，甚至可能为空！</p><p>要直观看到<code>map()</code>和<code>compactMap()</code>的区别，可以尝试下面这个例子：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fish&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> evensMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> evensCompactMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compactMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这段代码创建了一个字符串数组，然后分别使用<code>map()</code>和<code>compactMap()</code>将其转换为整数数组。代码运行后，<code>evensMap</code>会包含两个可选整数、一个<code>nil</code>和另一个可选整数，而<code>evensCompactMap</code>会包含三个实际的整数——没有可选类型，也没有<code>nil</code>。这样的结果要好得多！</p><h2 id="result类型" tabindex="-1">Result类型 <a class="header-anchor" href="#result类型" aria-label="Permalink to &quot;Result类型&quot;">​</a></h2><p>我们使用Swift的<code>Result</code>类型作为一种简单的方式，返回一个要么成功（带有对应值）要么失败（带有对应错误）的单一结果，但它还有一些重要特性，我认为在你自己的代码中会很有用。</p><p>首先，仔细想想就会发现，<code>Result</code>有点像一种更高级的可选类型。可选类型要么包含某种值（比如整数、字符串等），要么什么都不包含；而<code>Result</code>同样包含某种值，但在“另一种情况”下，它不是什么都没有，而是必须包含某种错误。</p><p>从底层实现来看，可选类型和<code>Result</code>都是用Swift枚举实现的，且都有两个枚举情况。对于可选类型，枚举名为<code>Optional</code>，枚举情况分别是表示<code>nil</code>的<code>.none</code>和带有关联值（如整数、字符串等）的<code>.some</code>；对于<code>Result</code>，枚举情况则是带有关联值的<code>.success</code>和带有另一种关联值的<code>.failure</code>。</p><p>两者之间唯一真正的区别在于，Swift为可选类型提供了语法糖——专门设计的简化语法，因为可选类型的使用非常普遍。比如，<code>if let</code>和可选链都是为可选类型设计的，而<code>Result</code>则没有这类特殊的语法支持。</p><p>其次，正如你所见，<code>Result</code>要么包含成功值，要么包含错误值，但如果需要，我们可以在<code>Result</code>和抛出函数（throwing function）之间灵活转换。</p><p>如果你有一个<code>Result</code>值，并且想回到<code>do</code>/<code>catch</code>的处理方式，只需调用<code>Result</code>的<code>get()</code>方法——如果<code>Result</code>是成功状态，这个方法会返回成功值；如果是失败状态，则会抛出对应的错误。</p><p>例如，看看下面这段代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NetworkError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> badURL</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Result&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, NetworkError&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">failure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.badURL)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> createResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这段代码定义了一种错误类型，创建了一个函数（该函数本应返回字符串或错误，但实际上总是返回错误），然后调用这个函数，并将其返回值赋给<code>result</code>。如果你想使用<code>do</code>/<code>catch</code>来处理这个值，可以像这样使用<code>get()</code>方法：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> successString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(successString)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;哎呀！出现了错误。&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>反过来，如果要从抛出代码创建<code>Result</code>值，你会发现<code>Result</code>有一个接受抛出闭包的初始化器。如果闭包成功返回一个值，这个值就会作为<code>Result</code>的成功情况；如果闭包抛出错误，这个错误就会作为<code>Result</code>的失败情况。</p><p>例如：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contentsOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: someURL) }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这段代码中，<code>result</code>的类型是<code>Result&lt;String, Error&gt;</code>——它没有特定的错误类型，因为<code>String(contentsOf:)</code>方法不会返回特定类型的错误。</p><p>关于<code>Result</code>，你需要知道的最后一点是，它拥有一些你已经熟悉的函数式方法，包括<code>map()</code>和<code>mapError()</code>。例如，<code>map()</code>方法会检查<code>Result</code>的状态，如果是成功状态，就会使用你提供的闭包将成功值转换为另一种类型（比如将字符串转换为整数）；但如果是失败状态，它就会直接保留失败结果，忽略你的转换操作。另一方面，<code>mapError()</code>会将错误从一种类型转换为另一种类型，如果你想在某个地方统一错误类型，这个方法会很有帮助。</p><p>这正是函数式编程的魅力之一：一旦你理解了<code>map()</code>这种“接受闭包并使用它进行转换”的本质，就会发现它不仅存在于数组中，还存在于<code>Result</code>甚至可选类型中！</p><h2 id="挑战任务" tabindex="-1">挑战任务 <a class="header-anchor" href="#挑战任务" aria-label="Permalink to &quot;挑战任务&quot;">​</a></h2><p>这次的挑战难度可高可低，取决于你想深入到什么程度，但项目的核心很简单：你需要构建一个应用，帮助用户掷骰子，并存储他们掷出的结果。</p><p>至少，你需要实现让用户掷骰子的功能，以及让用户查看之前掷骰子结果的功能。不过，如果你想进一步挑战自己，可以尝试完成以下一项或多项任务：</p><ol><li>让用户自定义要掷的骰子：骰子的数量，以及骰子的类型（4面、6面、8面、10面、12面、20面，甚至100面）。</li><li>显示掷出的骰子的总和。</li><li>使用JSON或SwiftData存储结果——只要能持久化存储就行。</li><li>掷骰子时添加触觉反馈。</li><li>更高难度的任务：让骰子掷出的数值在最终确定前，快速切换显示多个可能的值。</li></ol><p>这里说的“掷骰子”不需要制作复杂的3D效果——只需显示“掷出”的数字即可。</p><p>可能需要多花些功夫的是第5项任务：让结果在最终确定前快速切换显示多个值。最简单的实现方法是使用<code>Timer</code>，并在调用一定次数后取消定时器。</p><p>在开发过程中，请花点时间关注代码的可访问性——尝试用VoiceOver（屏幕阅读器）测试应用，确保它能尽可能正常地工作。</p>`,54)]))}const o=i(l,[["render",p]]);export{E as __pageData,o as default};
