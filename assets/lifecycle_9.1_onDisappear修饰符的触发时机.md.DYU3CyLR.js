import{_ as a,c as o,o as i,ag as r}from"./chunks/framework.Bw-5EFTY.js";const h=JSON.parse('{"title":"onDisappear修饰符的触发时机","description":"","frontmatter":{},"headers":[],"relativePath":"lifecycle/9.1_onDisappear修饰符的触发时机.md","filePath":"lifecycle/9.1_onDisappear修饰符的触发时机.md"}'),p={name:"lifecycle/9.1_onDisappear修饰符的触发时机.md"};function c(d,e,n,t,s,l){return i(),o("div",null,e[0]||(e[0]=[r('<h1 id="ondisappear修饰符的触发时机" tabindex="-1">onDisappear修饰符的触发时机 <a class="header-anchor" href="#ondisappear修饰符的触发时机" aria-label="Permalink to &quot;onDisappear修饰符的触发时机&quot;">​</a></h1><h2 id="ondisappear修饰符的触发时机-1" tabindex="-1">onDisappear修饰符的触发时机 <a class="header-anchor" href="#ondisappear修饰符的触发时机-1" aria-label="Permalink to &quot;onDisappear修饰符的触发时机&quot;">​</a></h2><p><code>onDisappear</code> 修饰符是 SwiftUI 中一个非常实用的工具，它允许你在视图从屏幕上消失时执行特定的操作。 🚀 理解它的触发时机至关重要，这样你才能有效地管理视图的生命周期。 当一个视图不再显示在屏幕上时，<code>onDisappear</code> 就会被调用。</p><p>这通常发生在几种情况下。 例如，当用户导航到另一个视图时，或者当包含该视图的父视图被移除时。 想象一下，你正在构建一个复杂的应用程序，其中包含许多动态加载和卸载的视图。</p><h2 id="视图消失的场景" tabindex="-1">视图消失的场景 <a class="header-anchor" href="#视图消失的场景" aria-label="Permalink to &quot;视图消失的场景&quot;">​</a></h2><p><code>onDisappear</code> 的触发场景非常多样。 你会发现它在以下几种情况中特别有用：</p><ul><li><strong>导航堆栈弹出</strong>: 当你使用 <code>NavigationView</code> 或 <code>NavigationStack</code> 并在用户点击返回按钮时，当前视图会从堆栈中弹出，此时 <code>onDisappear</code> 就会触发。 这是一个非常常见的场景！</li><li><strong>Sheet 或 FullScreenCover 关闭</strong>: 如果你使用 <code>sheet</code> 或 <code>fullScreenCover</code> 展示了一个模态视图，当这个模态视图被关闭时，它的 <code>onDisappear</code> 也会被调用。 💯</li><li><strong>条件视图移除</strong>: 当你使用 <code>if</code> 语句根据条件显示或隐藏视图时，如果条件变为 <code>false</code> 导致视图被移除，<code>onDisappear</code> 也会随之触发。</li></ul><h2 id="深入理解触发机制" tabindex="-1">深入理解触发机制 <a class="header-anchor" href="#深入理解触发机制" aria-label="Permalink to &quot;深入理解触发机制&quot;">​</a></h2><p><code>onDisappear</code> 的触发机制与 SwiftUI 的视图层级管理紧密相关。 当 SwiftUI 决定一个视图不再需要渲染时，它会执行一系列清理操作，其中就包括调用 <code>onDisappear</code>。 这确保了你可以在视图生命周期的最后阶段执行必要的清理工作。</p><p>例如，你可能需要取消网络请求，或者停止一个正在运行的计时器。 🎯 统计数据显示，大约 70% 的应用程序错误与资源未正确释放有关，因此掌握 <code>onDisappear</code> 至关重要。</p><h2 id="实际应用与注意事项" tabindex="-1">实际应用与注意事项 <a class="header-anchor" href="#实际应用与注意事项" aria-label="Permalink to &quot;实际应用与注意事项&quot;">​</a></h2><p>在实际开发中，<code>onDisappear</code> 是你进行资源清理的理想场所。 你可以利用它来：</p><ul><li>停止动画或计时器。</li><li>取消进行中的网络请求。</li><li>释放不再需要的内存资源。</li></ul><p>请记住，<code>onDisappear</code> 并不保证视图的 <code>deinit</code> 方法会立即被调用。 视图的实际销毁可能在 <code>onDisappear</code> 触发之后的一段时间发生。 因此，你应该将 <code>onDisappear</code> 视为一个“视图即将消失”的通知，而不是“视图已被销毁”的信号。 💡 这是一个细微但重要的区别。</p>',14)]))}const D=a(p,[["render",c]]);export{h as __pageData,D as default};
