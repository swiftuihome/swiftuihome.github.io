import{_ as i,c as a,o as n,ag as p}from"./chunks/framework.Bw-5EFTY.js";const g=JSON.parse('{"title":"第53天 项目 11 第一部分","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第53天_项目11_第一部分.md","filePath":"100days/第53天_项目11_第一部分.md"}'),t={name:"100days/第53天_项目11_第一部分.md"};function l(e,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[p(`<h1 id="第53天-项目-11-第一部分" tabindex="-1">第53天 项目 11 第一部分 <a class="header-anchor" href="#第53天-项目-11-第一部分" aria-label="Permalink to &quot;第53天 项目 11 第一部分&quot;">​</a></h1><p>今天，我们要启动另一个新项目，从这里开始，内容会变得更加深入，因为你将学习一项重要的新Swift技能、一项重要的新SwiftUI技能，以及一项重要的应用开发技能——在我们开发这个项目的过程中，这些这些技能都会派上用场。</p><p>你将学习的应用开发技能涉及Apple的一个框架：SwiftData。它负责管理数据库中的对象，包括读取、写入、筛选、排序等操作，在iOS、macOS等平台的应用开发中至关重要。之前我们直接将数据写入UserDefaults，但那只是帮助你学习的临时方案，而SwiftData才是真正的实用工具，无数应用都在使用它。</p><p>加拿大软件开发者罗布·派克（Go编程语言的创建者、Unix开发团队成员、UTF-8的联合创建者，同时也是出版作家）曾这样评价数据：</p><blockquote><p>“数据至上。如果你选择了合适的数据结构并合理组织，算法往往会不言自明。在编程中，核心是数据结构，而非算法。”</p></blockquote><p>这句话通常被简化为“用智能对象编写简单代码”，而你会发现，当对象由SwiftData支持时，其“智能程度”几乎达到了顶峰！</p><p><strong>今天你需要学习四个主题，从中你将了解@Binding、TextEditor、SwiftData等内容。</strong></p><ul><li>Bookworm：项目介绍</li><li>用@Binding创建自定义组件</li><li>用TextEditor接收多行文本输入</li><li>SwiftData与SwiftUI入门</li></ul><h2 id="bookworm-项目介绍" tabindex="-1">Bookworm：项目介绍 <a class="header-anchor" href="#bookworm-项目介绍" aria-label="Permalink to &quot;Bookworm：项目介绍&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月17日</p><p>在这个项目中，我们将开发一个应用，用于记录你读过的书籍以及你对这些书的评价。该项目的主题与第10个项目类似：先运用你已掌握的所有技能，再添加一些额外的新技能，让你的能力更上一层楼。</p><p>这次你将接触到SwiftData，它是Apple用于操作数据库的框架。本项目将作为SwiftData的入门介绍，后续我们会深入探讨更多细节。</p><p>同时，我们还将构建第一个自定义用户界面组件——一个星级评分组件，用户可以通过点击为每本书打分。这意味着我们要向你介绍另一个属性包装器@Binding——相信我，你最终会完全理解它的作用。</p><p>和往常一样，我们首先会梳理完成这个项目所需的所有新技术，所以请创建一个新的iOS应用，命名为Bookworm，使用App模板。</p><p><strong>重要提示：我知道你可能会忍不住，但请务必不要触碰存储选项，即使你看到其中有SwiftData选项也不要选择。</strong> 因为它会在项目中添加大量无用的代码，为了跟上后续的学习，你还得删除这些代码。</p><h2 id="用-binding创建自定义组件" tabindex="-1">用@Binding创建自定义组件 <a class="header-anchor" href="#用-binding创建自定义组件" aria-label="Permalink to &quot;用@Binding创建自定义组件&quot;">​</a></h2><p>作者：Paul Hudson 2024年4月11日</p><p>你已经了解到，SwiftUI的@State属性包装器可以让我们处理本地值类型，而@Bindable则能让我们与可观察类内部的属性创建绑定。不过，还有第三种选择，它的名称可能会让人有些困惑——@Binding。它可以让一个视图的@State属性与另一个视图共享，这样两个视图就指向同一个整数、字符串、布尔值等数据。</p><p>想一想：当我们创建切换开关（Toggle）时，会传入一个可以修改的布尔属性，就像这样：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rememberMe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Toggle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;记住我&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $rememberMe)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>那么，切换开关需要在用户交互时修改我们的布尔值，它是如何记住自己应该修改哪个值的呢？</p><p>这就需要@Binding发挥作用了：它允许我们在一个视图中存储一个可变值，而这个值实际上指向其他地方的某个值。以Toggle为例，开关会修改自身对布尔值的本地绑定，但在幕后，这实际上是在操作我们视图中的@State属性——它们读取和写入的是同一个布尔值。</p><p><strong>起初，你可能会对@Bindable和@Binding的区别感到非常困惑，但慢慢你就会理解。</strong></p><p>需要明确的是，@Bindable用于访问使用@Observable宏的共享类：我们在一个视图中用@State创建该类的实例，这样在该视图中就有了可用的绑定；而当我们要与其他视图共享这个类的实例时，就会使用@Bindable，这样SwiftUI也能在其他视图中创建绑定。</p><p>另一方面，@Binding则用于处理简单的值类型数据，而非独立的类。例如，你有一个存储布尔值、双精度浮点数、字符串数组等数据的@State属性，并且想要传递这个属性。这类数据不使用@Observable宏，所以我们不能用@Bindable。这时，我们就会使用@Binding，这样就能在多个地方共享这个布尔值或整数了。</p><p>这种特性使得@Bindable在创建自定义用户界面组件时极为重要。从本质上来说，用户界面组件和其他所有SwiftUI视图一样，但@Binding是它们的独特之处：虽然这些组件可能有自己的本地@State属性，但它们还会暴露@Binding属性，以便直接与其他视图交互。</p><p>为了演示这一点，我们来看一段代码，用它创建一个按下后能保持按下状态的自定义按钮。这个基础实现所用的知识都是你已经学过的：一个带内边距的按钮、用于背景的线性渐变、胶囊形的裁剪形状等——现在就把这段代码添加到ContentView.swift中：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PushButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> title: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isOn: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> onColors </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Color.red, Color.yellow]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offColors </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">white</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">white</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(title) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            isOn.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">toggle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LinearGradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">colors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: isOn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> onColors </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offColors, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">startPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .top, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">endPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .bottom))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foregroundStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.white)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">clipShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.capsule)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shadow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: isOn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这段代码中唯一稍显特别的地方是，我用属性来存储两种渐变颜色，这样创建按钮的代码就可以自定义这些颜色。</p><p>现在，我们可以在主用户界面中创建这样一个按钮，代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rememberMe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        VStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            PushButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;记住我&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: rememberMe)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rememberMe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;开启&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;关闭&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>按钮下方有一个文本视图，用于跟踪按钮的状态——运行代码，看看效果如何。</p><p>你会发现，点击按钮确实会改变按钮的外观，但文本视图并没有反映出这种变化，它始终显示“关闭”。显然，有什么东西发生了变化（因为按钮按下时外观会改变），但这种变化并没有传递到ContentView中。</p><p>问题在于，我们定义的是单向数据流：ContentView有一个rememberMe布尔值，用它来创建PushButton——按钮的初始值由ContentView提供。但是，一旦按钮创建完成，它就会接管这个值的控制权：按钮内部会将isOn属性在true和false之间切换，但不会把这种变化传递回ContentView。</p><p>这就出现了问题，因为现在有两个数据来源：ContentView存储一个值，PushButton存储另一个值。幸运的是，@Binding可以解决这个问题：它能在PushButton和使用它的视图之间建立双向连接，这样当一个值发生变化时，另一个值也会随之变化。</p><p>要切换到@Binding，我们只需做两处修改。首先，在PushButton中，将isOn属性修改为：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Binding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isOn: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其次，在ContentView中，修改创建按钮的代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PushButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;记住我&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isOn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $rememberMe)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里在rememberMe前面加了一个美元符号（$）——我们传递的是绑定本身，而不是其中的布尔值。</p><p>现在再次运行代码，你会发现一切都能正常工作了：切换按钮时，文本视图也会正确更新。</p><p>这就是@Binding的强大之处：在按钮看来，它只是在切换一个布尔值——它完全不知道还有其他视图在监听这个布尔值并根据变化做出反应。</p><h2 id="用texteditor接收多行文本输入" tabindex="-1">用TextEditor接收多行文本输入 <a class="header-anchor" href="#用texteditor接收多行文本输入" aria-label="Permalink to &quot;用TextEditor接收多行文本输入&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月17日</p><p>我们已经多次使用过SwiftUI的TextField视图，当用户需要输入短文本时，它非常好用。但是，对于较长的文本，你可能会想要改用TextEditor视图：它同样需要与一个文本字符串建立双向绑定，但它有一个额外的优势——支持多行文本输入，更适合为用户提供较大的输入空间。</p><p>由于TextEditor几乎没有特殊的配置选项，所以使用它实际上比使用TextField更简单：你无法调整它的样式或添加占位文本，只需将它与一个字符串绑定即可。不过，你需要注意确保它不会超出安全区域，否则输入会很不方便；可以将它嵌入到NavigationStack、Form等容器中。</p><p>例如，我们可以结合TextEditor和@AppStorage创建一个最简单的笔记应用，代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @AppStorage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;notes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        NavigationStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            TextEditor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $notes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">navigationTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;笔记&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>提示：@AppStorage并非为存储敏感信息设计，所以切勿用它存储任何私密内容。</strong></p><p>不过，我之前说“可能会想要改用TextEditor”而非“应该改用TextEditor”，是有原因的：SwiftUI还提供了第三种选择，在某些情况下效果更好。</p><p>创建TextField时，我们可以选择性地指定它可以沿某个轴扩展。这意味着文本框最初是一个普通的单行文本框，但当用户输入时，它可以像iMessage的文本框一样自动扩展。</p><p>代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @AppStorage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;notes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        NavigationStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            TextField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;输入文本&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $notes, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">axis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .vertical)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">textFieldStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.roundedBorder)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">navigationTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;笔记&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>你可以尝试一下，看看效果如何。</p><p>这两种方法你在不同场景下都会用到。虽然我喜欢TextField自动扩展的特性，但有时候，向用户展示一个较大的文本输入区域，让他们一开始就知道可以在这里输入大量内容，也是很有帮助的。</p><p><strong>提示：当视图处于Form内部时，SwiftUI通常会改变其外观，所以一定要分别在Form内部和外部尝试这两种视图，看看它们的差异。</strong></p><h2 id="swiftdata与swiftui入门" tabindex="-1">SwiftData与SwiftUI入门 <a class="header-anchor" href="#swiftdata与swiftui入门" aria-label="Permalink to &quot;SwiftData与SwiftUI入门&quot;">​</a></h2><p>作者：Paul Hudson 2024年5月29日</p><p>SwiftUI是一个强大的现代框架，可用于在Apple的所有平台上构建出色的应用；而SwiftData也是一个强大的现代框架，用于存储、查询和筛选数据。要是它们能完美配合，岂不是很棒？</p><p>事实上，它们不仅能出色地协同工作，而且所需的代码量少到让你难以置信——只需几分钟，你就能创建出很棒的功能。</p><p>首先，基础知识：SwiftData是一个对象图和持久化框架，简单来说，它允许我们定义对象及其属性，然后从持久化存储中读取和写入这些对象。</p><p>表面上看，这似乎和使用Codable与UserDefaults类似，但SwiftData要先进得多：它能够对数据进行排序和筛选，并且可以处理更大量的数据——实际上，它能存储的数据量没有限制。更棒的是，当你确实需要依赖它的高级功能时，SwiftData还提供了各种强大功能：iCloud同步、数据懒加载、撤销与重做等等。</p><p>在本项目中，我们只会用到SwiftData的一小部分功能，但后续会逐步扩展——目前我只想让你先对它有个初步了解。</p><p>之前创建Xcode项目时，我让你不要启用SwiftData支持，因为虽然它能帮你省去一些繁琐的设置代码，但同时也会添加大量无用的示例代码，最后你还得删除这些代码。</p><p>所以，接下来你要学习如何手动设置SwiftData。这个过程分为三步，首先我们要定义应用中需要使用的数据。</p><p>之前，我们定义数据的方式是创建一个名为Student.swift（或其他类似名称）的Swift文件，然后在文件中编写如下代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Observable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id: UUID</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: UUID, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们只需做两处微小的修改，就能将这个类转换为SwiftData对象——即可以存储在数据库中、与iCloud同步、可搜索、可排序等的对象。</p><p>首先，需要在文件顶部添加另一个导入语句：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SwiftData</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这行代码告诉Swift，我们要引入SwiftData的所有功能。</p><p>然后，将原来的代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Observable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>修改为：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Model</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>……就这样。只需这样修改，就能为SwiftData提供加载和保存Student对象所需的全部信息。现在，SwiftData还可以查询、删除这些对象，以及将它们与其他对象关联等。</p><p>这个类被称为SwiftData模型（model）：它定义了我们想要在应用中使用的某种数据。在幕后，@Model基于与@Observable相同的观察系统构建，这意味着它能与SwiftUI很好地配合使用。</p><p>定义好要使用的数据后，就可以进行SwiftData设置的第二步：编写少量Swift代码来加载这个模型。这段代码会告诉SwiftData在iPhone上准备好存储区域，用于读取和写入Student对象。</p><p>这项工作最好在App结构体中完成。每个项目都有一个这样的结构体，包括我们之前制作的所有项目，它相当于整个应用的启动入口。</p><p>由于这个项目名为Bookworm，所以我们的App结构体位于BookwormApp.swift文件中。该文件的代码应该如下所示：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SwiftUI</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@main</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BookwormApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">App </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Scene {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        WindowGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            ContentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到，这段代码与我们常见的视图代码有些相似：仍然需要导入SwiftUI（import SwiftUI），仍然使用结构体创建自定义类型，而且ContentView也在其中。其余部分是新内容，我们主要关注两点：</p><ol><li>@main行告诉Swift，这是应用的启动入口。从内部机制来说，当用户从iOS主屏幕启动应用时，正是这段代码启动了整个程序。</li><li>WindowGroup部分告诉SwiftUI，我们的应用可以在多个窗口中显示。这在iPhone上作用不大，但在iPad和macOS上就非常重要了。</li></ol><p>我们需要在这里告诉SwiftData为我们设置好所有存储，同样只需做两处微小的修改。</p><p>首先，在import SwiftUI旁边添加import SwiftData。我个人喜欢按字母顺序排列导入语句，但这并不是必须的。</p><p>其次，为WindowGroup添加一个修饰符，让SwiftData在应用的所有地方都可用：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">modelContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Student.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>模型容器（model container）是SwiftData对其数据存储区域的称呼。应用第一次运行时，SwiftData会创建底层的数据库文件；后续运行时，它会加载之前创建的数据库。</p><p>到目前为止，你已经了解了如何使用@Model创建数据模型，以及如何使用modelContainer()修饰符创建模型容器。第三步是模型上下文（model context），它实际上是数据的“实时”版本——当你加载对象并修改它们时，这些修改只存在于内存中，直到被保存。因此，模型上下文的作用是让我们在内存中操作所有数据，这比频繁地从磁盘读写数据要快得多。</p><p>每个SwiftData应用都需要一个模型上下文来工作，而我们其实已经创建了一个——使用modelContainer()修饰符时，它会自动创建。SwiftData会自动为我们创建一个模型上下文，称为主上下文（main context），并将其存储在SwiftUI的环境中。</p><p>至此，SwiftData的所有配置都已完成，接下来就到了有趣的部分：读取数据和写入数据。</p><p>从SwiftData中检索信息需要使用查询（query）——我们描述想要获取的数据、排序方式以及是否需要筛选，SwiftData就会返回所有匹配的数据。我们需要确保这个查询能实时更新，这样当学生对象被创建或删除时，用户界面也能保持同步。</p><p>SwiftUI为此提供了解决方案——没错，又是一个属性包装器。这次是@Query，只需在文件中添加import SwiftData，就可以使用它。</p><p>所以，在ContentView.swift文件的顶部添加SwiftData的导入语句，然后在ContentView结构体中添加以下属性：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Query</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> students: [Student]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这看起来就像一个普通的Student数组，但只需在前面加上@Query，就能让SwiftData从模型容器中加载学生对象——它会自动找到存储在环境中的主上下文，并通过该上下文查询容器。我们没有指定要加载哪些学生对象，也没有指定排序方式，所以会加载所有学生对象。</p><p>之后，我们就可以像使用普通Swift数组一样使用students了——将以下代码添加到视图的body中：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NavigationStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(students) { student </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(student.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">navigationTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;教室&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>你可以运行代码看看效果，但实际上意义不大——列表会是空的，因为我们还没有添加任何数据，数据库中没有内容。要解决这个问题，我们可以在列表下方添加一个按钮，每次点击就添加一个随机的学生对象，但首先需要添加一个新属性来访问之前创建的模型上下文。</p><p>现在在ContentView中添加以下属性：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\.modelContext) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> modelContext</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>添加好这个属性后，下一步就是创建一个按钮，生成随机的学生对象并将其保存到模型上下文中。为了让学生对象的名称更容易区分，我们可以创建firstNames和lastNames两个数组，然后使用randomElement()从每个数组中随机选择一个元素，组合成学生的姓名。</p><p>首先，为List添加以下工具栏：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">toolbar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;添加&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstNames </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;金妮&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;哈利&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;赫敏&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;卢娜&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;罗恩&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastNames </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;格兰杰&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;洛夫古德&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;波特&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;韦斯莱&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chosenFirstName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstNames.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randomElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chosenLastName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastNames.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randomElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 后续代码将在此处添加</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>注意：肯定会有人抱怨我在这里对randomElement()的调用使用了强制解包，但这些数组是我们手动创建的，里面肯定有元素——强制解包一定会成功。如果你实在不喜欢强制解包，可以用空合运算符设置一个默认值。</strong></p><p>接下来是关键部分：创建一个Student对象。将“// 后续代码将在此处添加”注释替换为以下代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> student </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UUID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(chosenFirstName)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \\(chosenLastName)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>最后，我们需要让模型上下文添加这个学生对象，这样它才会被保存。在按钮的操作闭包中添加最后一行代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modelContext.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(student)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>现在，你终于可以运行应用并尝试使用了——点击“添加”按钮几次，生成一些随机的学生对象，你应该会看到它们出现在列表中。更棒的是，重新启动应用后，这些学生对象仍然会存在，因为SwiftData已经自动保存了它们。</p><p>你可能会觉得，学了这么多内容，得到的结果却很简单，但实际上你已经了解了模型、模型容器和模型上下文是什么，并且掌握了如何插入和查询数据。在本项目的后续部分以及未来的学习中，我们会进一步探讨SwiftData，但目前你已经取得了不小的进步。</p><p>以上就是本项目概述的最后一部分，请准备好重置项目，开始真正的开发工作。重置操作包括重置ContentView.swift、BookwormApp.swift文件，并删除Student.swift文件。</p>`,112)]))}const o=i(t,[["render",l]]);export{g as __pageData,o as default};
