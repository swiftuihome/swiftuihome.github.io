import{_ as s,c as i,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"使用 EquatableView 减少不必要的刷新","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/10.4_使用 EquatableView 减少不必要的刷新.md","filePath":"advanced/10.4_使用 EquatableView 减少不必要的刷新.md"}'),l={name:"advanced/10.4_使用 EquatableView 减少不必要的刷新.md"};function t(p,a,h,k,d,r){return e(),i("div",null,a[0]||(a[0]=[n(`<h1 id="使用-equatableview-减少不必要的刷新" tabindex="-1">使用 EquatableView 减少不必要的刷新 <a class="header-anchor" href="#使用-equatableview-减少不必要的刷新" aria-label="Permalink to &quot;使用 EquatableView 减少不必要的刷新&quot;">​</a></h1><blockquote><p>在 SwiftUI 中，性能优化至关重要，尤其是在处理复杂的用户界面时。<code>EquatableView</code> 提供了一种巧妙的方法来减少不必要的视图刷新，从而提升应用的响应速度和流畅性。让我们一起深入了解如何使用它！🚀</p></blockquote><h2 id="了解-equatableview-的作用" tabindex="-1">了解 EquatableView 的作用 <a class="header-anchor" href="#了解-equatableview-的作用" aria-label="Permalink to &quot;了解 EquatableView 的作用&quot;">​</a></h2><p><code>EquatableView</code> 本质上是一个结构体，它包装了你的视图，并利用 <code>Equatable</code> 协议来确定视图的内容是否发生了变化。只有当内容真正改变时，才会触发视图的重新渲染。这可以显著减少不必要的计算，尤其是在列表或网格视图中。想象一下，如果一个列表中的某个单元格没有变化，但仍然被重新渲染，那将是多么浪费资源！<code>EquatableView</code> 正是为了解决这个问题而生的。</p><h2 id="如何使用-equatableview" tabindex="-1">如何使用 EquatableView <a class="header-anchor" href="#如何使用-equatableview" aria-label="Permalink to &quot;如何使用 EquatableView&quot;">​</a></h2><p>使用 <code>EquatableView</code> 非常简单。首先，确保你的视图符合 <code>Equatable</code> 协议。这意味着你需要实现 <code>==</code> 运算符，以便比较两个视图是否相等。然后，将你的视图包装在 <code>EquatableView</code> 中即可。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Equatable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Data: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(data)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: MyView, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: MyView) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lhs.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rhs.data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EquatableView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在这个例子中，只有当 <code>data</code> 属性发生变化时，<code>MyView</code> 才会重新渲染。是不是很方便？🎉</p><h2 id="equatableview-的优势与注意事项" tabindex="-1">EquatableView 的优势与注意事项 <a class="header-anchor" href="#equatableview-的优势与注意事项" aria-label="Permalink to &quot;EquatableView 的优势与注意事项&quot;">​</a></h2><p>使用 <code>EquatableView</code> 的主要优势在于性能提升。通过避免不必要的刷新，可以减少 CPU 和 GPU 的负担，从而提高应用的整体性能。根据一些测试，使用 <code>EquatableView</code> 可以减少高达 50% 的视图刷新次数！</p><p>然而，需要注意的是，<code>Equatable</code> 协议的实现必须准确。如果 <code>==</code> 运算符的实现不正确，可能会导致视图无法正确更新，或者仍然进行不必要的刷新。因此，务必仔细检查你的 <code>Equatable</code> 实现。此外，对于非常简单的视图，使用 <code>EquatableView</code> 可能会带来额外的开销，因为比较操作本身也需要时间。因此，在决定使用 <code>EquatableView</code> 之前，最好进行性能测试，以确保它确实能带来性能提升。</p><p>总而言之，<code>EquatableView</code> 是一个强大的工具，可以帮助你优化 SwiftUI 应用的性能。只要正确使用，就能显著提升用户体验。加油！💪</p>`,12)]))}const o=s(l,[["render",t]]);export{c as __pageData,o as default};
