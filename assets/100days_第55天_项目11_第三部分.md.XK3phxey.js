import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.ymCRTBvy.js";const o=JSON.parse('{"title":"第55天 项目 11 第三部分","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第55天_项目11_第三部分.md","filePath":"100days/第55天_项目11_第三部分.md"}'),p={name:"100days/第55天_项目11_第三部分.md"};function e(t,s,h,k,r,E){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="第55天-项目-11-第三部分" tabindex="-1">第55天 项目 11 第三部分 <a class="header-anchor" href="#第55天-项目-11-第三部分" aria-label="Permalink to &quot;第55天 项目 11 第三部分&quot;">​</a></h1><p>今天我们完成这款应用时，希望你能停下来想一想，自己已经掌握了多少 SwiftUI 知识。例如，构建应用的详情页会用到 SwiftData、VStack、ZStack、裁剪形状、间隔器等组件——这些内容你现在应该已经非常熟悉了，这足以说明你取得了多大的进步。</p><p>不过，总有新的知识需要学习，今天我们将学习如何删除 SwiftData 对象、如何使用 SortDescriptor 对查询结果进行排序，以及如何为警告框添加自定义按钮。正如美国哲学家弗农·霍华德所说：“永远以一种还有新东西要学的心态面对生活，你一定会有所收获”——我会在项目中加入这些小知识点来让你保持专注，但复习旧知识往往也同样重要！</p><p><strong>今天你需要完成三个主题的学习，通过这些内容，你将为应用添加排序、删除等功能。</strong></p><ul><li>展示书籍详情</li><li>使用 SortDescriptor 对 SwiftData 查询结果进行排序</li><li>从 SwiftData 查询结果中删除数据</li><li>使用警告框以编程方式关闭 NavigationLink</li></ul><p>又一款应用完成了——继续加油！</p><h2 id="展示书籍详情" tabindex="-1">展示书籍详情 <a class="header-anchor" href="#展示书籍详情" aria-label="Permalink to &quot;展示书籍详情&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月19日</p><p>当用户在 ContentView 中点击某本书时，我们将展示一个详情视图，其中包含更多信息——书籍的类型、简短评论等。我们还会复用之前创建的 RatingView，并对其进行自定义，让你看看 SwiftUI 有多灵活。</p><p>为了让这个页面更有趣，我们将为应用中的每个书籍类别添加对应的图片。我已经从 Unsplash 上挑选了一些图片，并将它们放在了本书的 project11-files 文件夹中——如果你还没有下载这些文件，请立即下载并将它们拖入资源目录中。</p><p>Unsplash 的许可协议允许我们将图片用于商业或非商业用途，无论是否注明出处，不过注明出处会更受欢迎。我添加的这些图片分别由瑞安·华莱士、尤金·特里古巴、杰米·斯特里特、阿尔瓦罗·塞拉诺、若昂·西拉斯、大卫·迪尔伯特和凯西·霍纳拍摄——如果你想获取原图，可以访问 <a href="https://unsplash.com/" target="_blank" rel="noreferrer">https://unsplash.com</a>。</p><p>接下来，创建一个名为“DetailView”的新 SwiftUI 视图，然后导入 SwiftData。这个新视图只需要一个属性，即它要展示的书籍，现在请添加这个属性：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> book: Book</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>仅仅添加这个属性就会导致 DetailView.swift 底部的预览代码报错。以前遇到这种情况很容易修复，只需传入一个示例对象即可，但涉及到 SwiftData 时情况会更复杂：创建一本新书意味着还需要一个视图上下文来承载它。</p><p>这是 SwiftData 中第一个真正需要注意的点；我们必须把所有细节都处理正确，它才能正常工作：</p><ol><li>要创建一个示例 Book 对象，必须先创建一个模型上下文。</li><li>模型上下文来自于创建的模型容器。</li><li>如果创建模型容器，我们不希望它实际存储任何数据，因此可以创建一个自定义配置，告诉 SwiftData 仅在内存中存储信息。这样所有数据都是临时的。</li></ol><p>听起来步骤很多，但实际上只需几行代码——我们需要手动创建模型容器，并使用一个名为 ModelConfiguration 的新类型来请求临时内存存储。完成这些后，就可以像往常一样创建 Book 对象，然后将其与模型容器一起传入 DetailView。</p><p>将当前的预览代码替换为以下内容：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">#Preview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ModelConfiguration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isStoredInMemoryOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> try</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ModelContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Book.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">configurations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: config)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Book</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Test Book&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">author</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Test Author&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">genre</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Fantasy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">review</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This was a great book; I really enjoyed it.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DetailView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">book</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: example)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">modelContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(container)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Failed to create preview: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(error.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">localizedDescription</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>是的，创建 Book 实例时并没有提到模型容器或配置，但这两者其实很重要：如果没有对应的容器就尝试创建 SwiftData 模型对象，代码很可能会崩溃。</p><p>解决完预览问题后，我们就可以把注意力转向更有趣的事情——设计视图本身。首先，我们将书籍类别图片和类别名称放在 ZStack 中，这样就能很好地将它们叠加在一起显示。我已经设计了一套我认为不错的样式，但你完全可以随意调整样式——不过我建议你一定要保留 ScrollView，因为无论评论有多长、用户使用什么设备，或者用户是否调整了字体大小，ScrollView 都能确保评论完全显示在屏幕上。</p><p>将当前的 body 属性替换为以下内容：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ScrollView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ZStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">alignment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .bottomTrailing) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book.genre)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">resizable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scaledToFit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book.genre.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uppercased</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.caption)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fontWeight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.black)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foregroundStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.white)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.black.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">opacity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.75</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">clipShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.capsule)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">navigationTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book.title)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">navigationBarTitleDisplayMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.inline)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scrollBounceBehavior</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.basedOnSize)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这段代码会将类别名称放在 ZStack 的右下角，为其添加背景色、粗体字体和少量内边距，使其更醒目。</p><p>在这个 ZStack 下方，我们将添加作者、评论和评分信息。我们不希望用户在这里调整评分，因此可以使用一个常量绑定，将 RatingView 变成一个简单的只读视图。更棒的是，由于我们使用 SF Symbols 来创建评分图片，只需添加一个简单的 font() 修饰符，就能无缝放大图片，更好地利用可用空间。</p><p>因此，在之前的 ZStack 正下方添加以下视图：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book.author)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.title)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foregroundStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.secondary)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book.review)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RatingView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rating</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book.rating))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.largeTitle)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>至此，DetailView 就完成了，接下来回到 ContentView.swift，为 List 视图添加一个导航目标：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">navigationDestination</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Book.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { book </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    DetailView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">book</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: book)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>现在再次运行应用，你应该可以点击已添加的任何书籍，在新的详情视图中查看它们的信息了。</p><h2 id="使用-sortdescriptor-对-swiftdata-查询结果进行排序" tabindex="-1">使用 SortDescriptor 对 SwiftData 查询结果进行排序 <a class="header-anchor" href="#使用-sortdescriptor-对-swiftdata-查询结果进行排序" aria-label="Permalink to &quot;使用 SortDescriptor 对 SwiftData 查询结果进行排序&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月19日</p><p>当使用 @Query 从 SwiftData 中获取对象时，你可以指定数据的排序方式——是按某个字段的字母顺序排序，还是按数字从大到小排序？无论选择哪种方式，最好都指定一种排序方式，这样用户就能获得可预测的使用体验。</p><p>在这个项目中，有多个字段可用于排序：书籍的标题、作者或评分都是合理的选择，但我们不必只依赖一个字段——你可以指定多个排序字段，例如先按评分从高到低排序，然后以书名作为平局决胜因素。</p><p>查询排序有两种方式：一种简单方式，只允许按一个字段排序；另一种更高级的方式，允许使用一个名为 SortDescriptor 的新类型的数组。</p><p>使用简单方式时，我们可以要求书籍按标题的字母顺序排列：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \\Book.title) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> books: [Book]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或者，我们可以要求按评分从高到低排序：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \\Book.rating, order</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .reverse) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> books: [Book]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这种方式在只需按单个字段排序时效果很好，但通常来说，最好再设置一个备用字段——比如“先按评分排序，再按标题排序”，这样能让应用的使用体验更具可预测性，这总是一件好事。</p><p>这需要通过 SortDescriptor 类型来实现，我们可以用一个或两个值来创建它：要排序的属性，以及（可选的）是否反向排序。例如，我们可以像这样按标题的字母顺序排序：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SortDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\Book.title)]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> books: [Book]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>与简单排序方式一样，使用 SortDescriptor 对结果进行排序时，默认按升序排列（文本按字母顺序，数字从小到大），但如果想反向排序，可以使用以下代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SortDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\Book.title, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">order</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .reverse)]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> books: [Book]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>你可以指定多个排序描述符，它们会按照你提供的顺序生效。例如，如果用户先添加了皮特·哈米尔所著的《Forever》，之后又添加了朱迪·布鲁姆所著的《Forever》——这是两本完全不同的书，只是书名碰巧相同——这时指定第二个排序字段就很有帮助。</p><p>因此，我们可以先按书籍标题升序排序，再按书籍作者升序排序，代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sort</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    SortDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\Book.title),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    SortDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\Book.author)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> books: [Book]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>除非有大量具有相似值的数据，否则添加第二个甚至第三个排序字段对性能几乎没有影响。例如，在我们的书籍数据中，几乎每本书的标题都是唯一的，因此从性能角度来看，添加次要排序字段几乎无关紧要。</p><h2 id="从-swiftdata-查询结果中删除数据" tabindex="-1">从 SwiftData 查询结果中删除数据 <a class="header-anchor" href="#从-swiftdata-查询结果中删除数据" aria-label="Permalink to &quot;从 SwiftData 查询结果中删除数据&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月19日</p><p>我们已经使用 @Query 将 SwiftData 对象放入 SwiftUI 的 List 中，只需再做一点工作，就能同时启用滑动删除功能和专门的“编辑/完成”按钮。</p><p>与处理普通数据数组一样，大部分工作是通过给 ForEach 添加 onDelete(perform:) 修饰符来完成的，但与直接从数组中删除项目不同，我们需要在查询结果中找到要删除的对象，然后使用该对象在模型上下文中调用 delete() 方法。删除所有对象后，SwiftData 的自动保存系统会启动，并将这些更改永久应用。</p><p>首先，在 ContentView 中添加以下方法：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deleteBooks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">at</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offsets: IndexSet) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offsets {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 在查询结果中找到这本书</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> book </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> books[offset]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 从上下文中删除它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        modelContext.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>我们可以通过给 ContentView 中的 ForEach 添加 onDelete(perform:) 修饰符来触发这个方法，但要记住：修饰符需要添加在 ForEach 上，而不是 List 上。</p><p>现在添加这个修饰符：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">onDelete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">perform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: deleteBooks)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样就实现了滑动删除功能，我们还可以更进一步，添加一个“编辑/完成”按钮。在 ContentView 中找到 toolbar() 修饰符，然后添加另一个 ToolbarItem：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ToolbarItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">placement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .topBarLeading) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    EditButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>至此，ContentView 就完成了，尝试运行应用吧——现在你可以自由添加和删除书籍，既可以通过滑动删除，也可以使用编辑按钮删除。</p><h2 id="使用警告框以编程方式关闭-navigationlink" tabindex="-1">使用警告框以编程方式关闭 NavigationLink <a class="header-anchor" href="#使用警告框以编程方式关闭-navigationlink" aria-label="Permalink to &quot;使用警告框以编程方式关闭 NavigationLink&quot;">​</a></h2><p>作者：Paul Hudson 2023年11月19日</p><p>你已经了解到，NavigationLink 可以让我们跳转到详情页，详情页既可以是自定义视图，也可以是 SwiftUI 的内置类型（如 Text 或 Image）。由于我们处于 NavigationStack 中，iOS 会自动提供一个“返回”按钮，让用户回到上一个页面，用户也可以从左边缘滑动来返回。不过，有时候以编程方式返回会很有用——也就是说，在我们需要的时候（而不是用户滑动的时候）回到上一个页面。</p><p>我们之前已经讨论过这个话题，希望这次对你来说只是一次很好的练习：我们将为应用添加最后一个功能，即删除用户当前查看的书籍。要实现这个功能，我们需要显示一个警告框，询问用户是否确定要删除该书籍，如果用户确认，就从当前的模型上下文中删除该书籍。删除完成后，当前页面就没有存在的必要了（因为它关联的书籍已经不存在了），所以我们要关闭当前视图——将其从 NavigationStack 的栈顶移除，从而回到上一个页面。</p><p>首先，我们需要在 DetailView 结构体中添加三个新属性：一个用于存储 SwiftData 模型上下文（以便删除数据），一个用于存储关闭操作（以便将视图从导航栈中移除），还有一个用于控制是否显示删除确认警告框。</p><p>因此，首先在 DetailView 中添加以下三个新属性：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\.modelContext) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> modelContext</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\.dismiss) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dismiss</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> showingDeleteAlert </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第二步是编写一个方法，从模型上下文中删除当前书籍，并关闭当前视图。无论这个视图是通过 navigation link 还是 sheet 显示的，我们都使用相同的 dismiss() 代码。</p><p>现在在 DetailView 中添加这个方法：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deleteBook</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    modelContext.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(book)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    dismiss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>第三步是添加一个 alert() 修饰符，监听 showingDeleteAlert 的值，并询问用户是否确认删除操作。到目前为止，我们使用的都是只有一个关闭按钮的简单警告框，但这里我们需要两个按钮：一个用于删除书籍，另一个用于取消操作。这两个按钮都有特定的按钮角色，可以自动呈现正确的样式，所以我们会使用这些角色。</p><p>苹果对警告框文本的标注有非常明确的指导原则，核心内容如下：如果是简单的“我明白了”之类的确认，使用“确定”（OK）就可以；但如果需要用户做出选择，就应该避免使用“是”（Yes）和“否”（No）这样的标题，而是使用动词，如“忽略”（Ignore）、“回复”（Reply）和“确认”（Confirm）。</p><p>在这个例子中，我们将为破坏性按钮使用“删除”（Delete），然后在旁边提供一个取消按钮，让用户在不想删除时可以退出操作。因此，给 DetailView 中的 ScrollView 添加以下修饰符：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Delete book&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isPresented</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $showingDeleteAlert) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Delete&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">role</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .destructive, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: deleteBook)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Cancel&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">role</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .cancel) { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Are you sure?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>最后一步是添加一个工具栏项，启动删除流程——只需翻转 showingDeleteAlert 的布尔值即可，因为我们的 alert() 修饰符已经在监听这个值了。因此，给 ScrollView 添加最后一个修饰符：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">toolbar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Delete this book&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">systemImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;trash&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        showingDeleteAlert </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>现在，你既可以在 ContentView 中通过滑动删除或编辑按钮删除书籍，也可以导航到 DetailView，然后点击其中专门的删除按钮——点击后会删除书籍、更新 ContentView 中的列表，然后自动关闭详情视图。</p><p>又一款应用完成了——做得好！</p>`,78)]))}const g=i(p,[["render",e]]);export{o as __pageData,g as default};
