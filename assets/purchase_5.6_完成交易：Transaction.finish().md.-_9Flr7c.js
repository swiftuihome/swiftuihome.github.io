import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.Bw-5EFTY.js";const o=JSON.parse('{"title":"完成交易：Transaction.finish()","description":"","frontmatter":{},"headers":[],"relativePath":"purchase/5.6_完成交易：Transaction.finish().md","filePath":"purchase/5.6_完成交易：Transaction.finish().md"}'),t={name:"purchase/5.6_完成交易：Transaction.finish().md"};function h(p,s,l,r,k,c){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="完成交易-transaction-finish" tabindex="-1">完成交易：Transaction.finish() <a class="header-anchor" href="#完成交易-transaction-finish" aria-label="Permalink to &quot;完成交易：Transaction.finish()&quot;">​</a></h1><h2 id="为什么完成交易至关重要" tabindex="-1">为什么完成交易至关重要？ <a class="header-anchor" href="#为什么完成交易至关重要" aria-label="Permalink to &quot;为什么完成交易至关重要？&quot;">​</a></h2><p>完成交易是订阅流程中不可或缺的一步。 🚀 它告诉StoreKit您已经成功处理了购买。 如果不调用 <code>finish()</code>，交易将保持挂起状态。</p><p>这意味着用户每次启动您的应用时，StoreKit都会尝试重新交付该交易。 这会导致重复的通知和潜在的混乱。</p><p>想象一下，用户购买了一项订阅，但每次打开应用都收到购买成功的提示。 这会非常令人沮丧！</p><h2 id="如何调用-transaction-finish" tabindex="-1">如何调用 <code>Transaction.finish()</code> <a class="header-anchor" href="#如何调用-transaction-finish" aria-label="Permalink to &quot;如何调用 \`Transaction.finish()\`&quot;">​</a></h2><p>调用 <code>Transaction.finish()</code> 非常简单。 您需要在处理完交易的所有逻辑之后执行此操作。</p><p>这包括验证签名、更新用户界面以及解锁高级功能。 确保所有这些步骤都已完成。</p><p>通常，您会在 <code>Transaction.updates</code> 监听器内部调用它。 这是一个关键的位置。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> transaction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Transaction.updates {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> transaction {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">verified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> verifiedTransaction)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 处理验证过的交易</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> verifiedTransaction.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">finish</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在这里调用 finish()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unverified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unverifiedTransaction)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 处理未验证的交易</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="finish-的最佳实践" tabindex="-1"><code>finish()</code> 的最佳实践 <a class="header-anchor" href="#finish-的最佳实践" aria-label="Permalink to &quot;\`finish()\` 的最佳实践&quot;">​</a></h2><p>调用 <code>finish()</code> 的时机非常重要。 您应该在以下情况后立即调用它：</p><ul><li><strong>成功验证交易：</strong> 确保交易的JWS签名有效。</li><li><strong>更新用户权利：</strong> 用户已获得其购买的订阅或内容。</li><li><strong>持久化数据：</strong> 购买信息已安全存储在您的服务器或本地。</li></ul><p>例如，如果您的应用需要与后端服务器同步订阅状态，请在服务器确认更新后调用 <code>finish()</code>。 这样可以确保数据一致性。</p><h2 id="确保交易完成的可靠性" tabindex="-1">确保交易完成的可靠性 <a class="header-anchor" href="#确保交易完成的可靠性" aria-label="Permalink to &quot;确保交易完成的可靠性&quot;">​</a></h2><p>即使应用崩溃，StoreKit也会确保交易最终完成。 它会持续尝试重新交付未完成的交易。</p><p>这为您提供了一个强大的容错机制。 您可以放心，即使出现意外情况，交易也不会丢失。</p><p>根据统计，超过99%的交易在首次处理时就能成功完成。 剩下的1%通常是由于网络问题或应用中断。</p><p>通过正确使用 <code>finish()</code>，您可以显著提高用户体验。 🥳 您的用户会感谢您流畅的购买流程。</p>`,19)]))}const E=i(t,[["render",h]]);export{o as __pageData,E as default};
