import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const o=JSON.parse('{"title":"使用 where 子句约束泛型类型","description":"","frontmatter":{},"headers":[],"relativePath":"refactor/6.2_使用`where`子句约束泛型类型.md","filePath":"refactor/6.2_使用`where`子句约束泛型类型.md"}'),h={name:"refactor/6.2_使用`where`子句约束泛型类型.md"};function l(t,s,p,k,r,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="使用-where-子句约束泛型类型" tabindex="-1">使用 <code>where</code> 子句约束泛型类型 <a class="header-anchor" href="#使用-where-子句约束泛型类型" aria-label="Permalink to &quot;使用 \`where\` 子句约束泛型类型&quot;">​</a></h1><p>在 SwiftUI 中，泛型让你的代码更灵活、更具可重用性。但有时，你可能需要限制泛型类型，确保它们符合特定的条件。这时，<code>where</code> 子句就派上用场啦！🎉</p><p><code>where</code> 子句允许你指定泛型类型必须满足的条件。这就像给你的泛型类型设置了一个“门槛”，只有符合条件的类型才能通过。</p><h2 id="where-子句的基本用法" tabindex="-1"><code>where</code> 子句的基本用法 <a class="header-anchor" href="#where-子句的基本用法" aria-label="Permalink to &quot;\`where\` 子句的基本用法&quot;">​</a></h2><p><code>where</code> 子句通常用于以下几种情况：</p><ul><li><strong>协议一致性</strong>: 确保泛型类型遵循特定的协议。</li><li><strong>类型相等</strong>: 限制泛型类型必须是某个特定的类型。</li><li><strong>关联类型约束</strong>: 对协议中定义的关联类型进行约束。</li></ul><p>例如，假设你有一个函数，它只应该处理遵循 <code>Equatable</code> 协议的类型。你可以这样使用 <code>where</code> 子句：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> areEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: T, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: T) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Equatable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这个例子中，<code>where T: Equatable</code> 确保了 <code>T</code> 必须遵循 <code>Equatable</code> 协议。这意味着你只能传递可以比较的类型给这个函数。</p><h2 id="多个约束条件" tabindex="-1">多个约束条件 <a class="header-anchor" href="#多个约束条件" aria-label="Permalink to &quot;多个约束条件&quot;">​</a></h2><p><code>where</code> 子句还可以包含多个约束条件，使用逗号分隔。这让你能够更精确地控制泛型类型的范围。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: T) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Numeric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理集合中的数字数据</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;集合中的元素类型是数字&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在这个例子中，<code>T</code> 必须遵循 <code>Collection</code> 协议，并且 <code>T</code> 的元素类型必须遵循 <code>Numeric</code> 协议。这确保了函数只能处理包含数字的集合。</p><h2 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h2><p><code>where</code> 子句在构建通用组件时非常有用。例如，你可以创建一个通用的列表视图，只显示特定类型的元素：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ItemView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Identifiable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item: T</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">describing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: item.id))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里，<code>where T: Identifiable</code> 确保了 <code>ItemView</code> 只能用于遵循 <code>Identifiable</code> 协议的类型。这可以防止你在视图中使用不兼容的数据类型。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>where</code> 子句是 SwiftUI 中一个强大的工具，可以帮助你编写更安全、更灵活的泛型代码。通过使用 <code>where</code> 子句，你可以精确地控制泛型类型的范围，确保你的代码只处理符合特定条件的类型。记住，合理使用 <code>where</code> 子句可以提高代码的可读性和可维护性！👍</p>`,19)]))}const E=i(h,[["render",l]]);export{o as __pageData,E as default};
