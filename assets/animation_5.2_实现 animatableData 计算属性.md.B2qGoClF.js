import{_ as s,c as i,o as n,ag as e}from"./chunks/framework.ymCRTBvy.js";const E=JSON.parse('{"title":"5.2_实现 animatableData 计算属性","description":"","frontmatter":{},"headers":[],"relativePath":"animation/5.2_实现 animatableData 计算属性.md","filePath":"animation/5.2_实现 animatableData 计算属性.md"}'),l={name:"animation/5.2_实现 animatableData 计算属性.md"};function t(p,a,h,k,r,d){return n(),i("div",null,a[0]||(a[0]=[e(`<h1 id="_5-2-实现-animatabledata-计算属性" tabindex="-1">5.2_实现 animatableData 计算属性 <a class="header-anchor" href="#_5-2-实现-animatabledata-计算属性" aria-label="Permalink to &quot;5.2_实现 animatableData 计算属性&quot;">​</a></h1><h2 id="深入理解-animatabledata" tabindex="-1">深入理解 <code>animatableData</code> <a class="header-anchor" href="#深入理解-animatabledata" aria-label="Permalink to &quot;深入理解 \`animatableData\`&quot;">​</a></h2><p><code>Animatable</code> 协议的核心在于 <code>animatableData</code> 计算属性。它允许您将自定义视图的任何可动画属性转换为 SwiftUI 可以理解和插值的单一 <code>VectorArithmetic</code> 类型。这真是太棒了！🚀</p><p>当您想要为自定义视图添加动画时，<code>animatableData</code> 是您的秘密武器。它充当了视图状态和动画系统之间的桥梁。您会发现，掌握它能让您的动画效果提升一个档次。</p><h2 id="如何实现-animatabledata" tabindex="-1">如何实现 <code>animatableData</code> <a class="header-anchor" href="#如何实现-animatabledata" aria-label="Permalink to &quot;如何实现 \`animatableData\`&quot;">​</a></h2><p>实现 <code>animatableData</code> 属性需要您将视图中所有需要动画的属性打包成一个 <code>VectorArithmetic</code> 类型。通常，这会是 <code>CGFloat</code> 或 <code>AnimatablePair</code>。例如，如果您有一个自定义的 <code>Shape</code>，并且想要动画化它的某个半径，您可以这样做：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyCircle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animatable </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> radius: CGFloat</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animatableData: CGFloat {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { radius }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { radius </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... 绘制路径 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这使得 <code>radius</code> 属性能够平滑地进行动画过渡。是不是很简单？✨</p><h2 id="处理多个可动画属性" tabindex="-1">处理多个可动画属性 <a class="header-anchor" href="#处理多个可动画属性" aria-label="Permalink to &quot;处理多个可动画属性&quot;">​</a></h2><p>当您的视图有多个需要动画的属性时，<code>AnimatablePair</code> 就派上用场了。它允许您将两个 <code>VectorArithmetic</code> 类型组合在一起。想象一下，您有一个自定义视图，既要动画化宽度，又要动画化高度：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyRectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animatable </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> width: CGFloat</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height: CGFloat</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animatableData: AnimatablePair&lt;CGFloat, CGFloat&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AnimatablePair</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(width, height) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue.second</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">frame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: width, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: height)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foregroundColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.blue)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>通过 <code>AnimatablePair</code>，您可以轻松地同时动画化 <code>width</code> 和 <code>height</code>。这种灵活性让您能够创建极其复杂的动画效果。</p><h2 id="animatabledata-的幕后原理" tabindex="-1"><code>animatableData</code> 的幕后原理 <a class="header-anchor" href="#animatabledata-的幕后原理" aria-label="Permalink to &quot;\`animatableData\` 的幕后原理&quot;">​</a></h2><p>当 SwiftUI 执行动画时，它会在动画的起始值和结束值之间对 <code>animatableData</code> 进行插值。例如，如果 <code>radius</code> 从 10 动画到 100，SwiftUI 会在动画过程中计算出 10 到 100 之间的所有中间值。</p><ul><li><strong>插值过程</strong>: SwiftUI 会在每一帧更新 <code>animatableData</code> 的值。</li><li><strong>视图重绘</strong>: 每次 <code>animatableData</code> 更新时，视图都会根据新的值进行重绘。</li><li><strong>平滑过渡</strong>: 这种连续的更新和重绘创造了平滑的动画效果。</li></ul><p>这种机制确保了无论您的自定义属性多么复杂，只要它们能被表示为 <code>VectorArithmetic</code> 类型，就能实现流畅的动画。大约 90% 的自定义动画都依赖于此。这绝对是您动画工具箱中的必备技能！💪</p>`,16)]))}const o=s(l,[["render",t]]);export{E as __pageData,o as default};
