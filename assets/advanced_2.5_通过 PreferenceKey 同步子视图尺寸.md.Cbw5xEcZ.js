import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const E=JSON.parse('{"title":"通过 PreferenceKey 同步子视图尺寸","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/2.5_通过 PreferenceKey 同步子视图尺寸.md","filePath":"advanced/2.5_通过 PreferenceKey 同步子视图尺寸.md"}'),l={name:"advanced/2.5_通过 PreferenceKey 同步子视图尺寸.md"};function p(h,s,t,r,k,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="通过-preferencekey-同步子视图尺寸" tabindex="-1">通过 PreferenceKey 同步子视图尺寸 <a class="header-anchor" href="#通过-preferencekey-同步子视图尺寸" aria-label="Permalink to &quot;通过 PreferenceKey 同步子视图尺寸&quot;">​</a></h1><h2 id="理解尺寸同步的挑战" tabindex="-1">理解尺寸同步的挑战 <a class="header-anchor" href="#理解尺寸同步的挑战" aria-label="Permalink to &quot;理解尺寸同步的挑战&quot;">​</a></h2><p>在 SwiftUI 中，子视图的尺寸通常由其内容和父视图的布局规则决定。 然而，有时您需要父视图知道其子视图的实际渲染尺寸。 这是一个常见的布局挑战。 比如，您可能需要根据子视图的宽度来调整父视图的布局。 传统方法可能涉及复杂的几何计算。 🚀</p><p>PreferenceKey 提供了一种优雅的解决方案。 它允许子视图“向上”传递信息。 这种逆向数据流非常强大。 您可以轻松地将子视图的尺寸信息传递给父视图。 想象一下，一个动态的标签云，每个标签的宽度都不同。 父视图需要知道这些宽度来正确排列它们。</p><h2 id="preferencekey-实现尺寸同步" tabindex="-1">PreferenceKey 实现尺寸同步 <a class="header-anchor" href="#preferencekey-实现尺寸同步" aria-label="Permalink to &quot;PreferenceKey 实现尺寸同步&quot;">​</a></h2><p>要通过 PreferenceKey 同步子视图尺寸，您需要定义一个自定义的 PreferenceKey。 这个 Key 将存储尺寸信息。 通常，我们会存储 <code>CGSize</code> 或 <code>CGFloat</code>。 让我们以 <code>ViewDimensionsPreferenceKey</code> 为例。 它的 <code>defaultValue</code> 通常是一个空数组或默认值。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewDimensionsPreferenceKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PreferenceKey </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> defaultValue: [CGSize] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [CGSize], </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [CGSize]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        value.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contentsOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nextValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接下来，您需要在子视图中使用 <code>.preference(key:value:)</code> 修饰符。 在这里，您将子视图的尺寸作为值传递。 您可以使用 <code>GeometryReader</code> 来获取子视图的实际尺寸。 这是一个非常关键的步骤。 🎯</p><ul><li><strong>步骤一</strong>: 定义 <code>PreferenceKey</code> 来存储尺寸数组。</li><li><strong>步骤二</strong>: 在子视图中使用 <code>GeometryReader</code> 获取其尺寸。</li><li><strong>步骤三</strong>: 使用 <code>.preference</code> 将尺寸发送到父视图。</li></ul><h2 id="实际应用与监听" tabindex="-1">实际应用与监听 <a class="header-anchor" href="#实际应用与监听" aria-label="Permalink to &quot;实际应用与监听&quot;">​</a></h2><p>在父视图中，您可以使用 <code>.onPreferenceChange()</code> 修饰符来监听尺寸的变化。 当子视图的尺寸更新时，这个闭包会被调用。 您可以在这里获取到所有子视图的尺寸数组。 这是一个非常灵活的机制。 🤩</p><p>例如，您可以创建一个 <code>HStack</code>，其中包含多个文本视图。 每个文本视图的宽度都可能不同。 通过 PreferenceKey，父视图可以收集这些宽度。 然后，父视图可以根据这些宽度来调整自身的布局。 比如，确保所有文本视图的总宽度不超过屏幕宽度。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ParentView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childSizes: [CGSize] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        VStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // ... 其他内容</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            ChildView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">onPreferenceChange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ViewDimensionsPreferenceKey.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { preferences </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.childSizes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> preferences</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;子视图尺寸已更新: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childSizes</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这种方法在构建复杂、动态的布局时非常有用。 您可以轻松地实现各种自适应和响应式设计。 比如，一个流式布局，其中项目会根据可用空间自动换行。 这种能力让您的 SwiftUI 布局更加强大和灵活。 🚀 超过 70% 的复杂 SwiftUI 应用都受益于 PreferenceKey。</p><h2 id="优势与最佳实践" tabindex="-1">优势与最佳实践 <a class="header-anchor" href="#优势与最佳实践" aria-label="Permalink to &quot;优势与最佳实践&quot;">​</a></h2><p>使用 PreferenceKey 同步子视图尺寸带来了显著的优势。 它提供了一种清晰、解耦的方式来处理布局信息。 您不再需要通过复杂的绑定或环境对象来传递尺寸。 这使得代码更易于理解和维护。 维护性大大提高！</p><ul><li><strong>解耦</strong>: 子视图和父视图之间的尺寸信息传递是解耦的。</li><li><strong>灵活性</strong>: 可以轻松地处理动态变化的子视图尺寸。</li><li><strong>可读性</strong>: 代码逻辑更清晰，易于理解。</li></ul><p>最佳实践包括为每个需要同步的特定信息定义独立的 PreferenceKey。 避免将所有信息都塞进一个 PreferenceKey。 保持 PreferenceKey 的职责单一。 这样可以提高代码的可读性和可维护性。 记住，清晰的代码是成功的关键！ 🌟</p>`,18)]))}const y=i(l,[["render",p]]);export{E as __pageData,y as default};
