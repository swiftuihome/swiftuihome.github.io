import{_ as e,c as t,o as i,ag as r}from"./chunks/framework.Bw-5EFTY.js";const p=JSON.parse('{"title":"SwiftUI框架核心：声明式设计与数据驱动思想","description":"","frontmatter":{},"headers":[],"relativePath":"thinking/目录.md","filePath":"thinking/目录.md"}'),o={name:"thinking/目录.md"};function n(h,a,_,l,d,s){return i(),t("div",null,a[0]||(a[0]=[r('<h1 id="swiftui框架核心-声明式设计与数据驱动思想" tabindex="-1">SwiftUI框架核心：声明式设计与数据驱动思想 <a class="header-anchor" href="#swiftui框架核心-声明式设计与数据驱动思想" aria-label="Permalink to &quot;SwiftUI框架核心：声明式设计与数据驱动思想&quot;">​</a></h1><h2 id="第1章-声明式语法基础" tabindex="-1">第1章 声明式语法基础 <a class="header-anchor" href="#第1章-声明式语法基础" aria-label="Permalink to &quot;第1章 声明式语法基础&quot;">​</a></h2><p>1.1_描述“什么”而非“如何” 1.2_与命令式UI（UIKit）的对比 1.3_代码可读性与简洁性优势 1.4_UI即状态的函数</p><h2 id="第2章-视图作为值类型" tabindex="-1">第2章 视图作为值类型 <a class="header-anchor" href="#第2章-视图作为值类型" aria-label="Permalink to &quot;第2章 视图作为值类型&quot;">​</a></h2><p>2.1_视图是轻量级结构体（Struct） 2.2_视图的创建与销毁成本低 2.3_避免复杂的视图层级和引用循环 2.4_值语义对UI一致性的保障</p><h2 id="第3章-单一数据源-single-source-of-truth" tabindex="-1">第3章 单一数据源（Single Source of Truth） <a class="header-anchor" href="#第3章-单一数据源-single-source-of-truth" aria-label="Permalink to &quot;第3章 单一数据源（Single Source of Truth）&quot;">​</a></h2><p>3.1_数据是驱动UI更新的唯一来源 3.2_避免UI状态不一致问题 3.3_简化状态管理逻辑 3.4_数据流的单向性原则</p><h2 id="第4章-状态管理属性包装器" tabindex="-1">第4章 状态管理属性包装器 <a class="header-anchor" href="#第4章-状态管理属性包装器" aria-label="Permalink to &quot;第4章 状态管理属性包装器&quot;">​</a></h2><p>4.1_@State：管理本地简单值类型状态 4.2_@Binding：创建双向数据绑定 4.3_@StateObject：管理引用类型对象的生命周期 4.4_@ObservedObject：订阅外部对象的更新 4.5_@EnvironmentObject：在视图层级中共享数据 4.6_@Environment：读取系统环境值</p><h2 id="第5章-ui自动更新机制" tabindex="-1">第5章 UI自动更新机制 <a class="header-anchor" href="#第5章-ui自动更新机制" aria-label="Permalink to &quot;第5章 UI自动更新机制&quot;">​</a></h2><p>5.1_状态变化如何触发视图重绘 5.2_视图依赖关系图的构建 5.3_最小化视图更新范围的策略 5.4_数据流的可预测性</p><h2 id="第6章-组合优于继承" tabindex="-1">第6章 组合优于继承 <a class="header-anchor" href="#第6章-组合优于继承" aria-label="Permalink to &quot;第6章 组合优于继承&quot;">​</a></h2><p>6.1_通过组合小视图构建复杂界面 6.2_视图的可复用性设计 6.3_避免深度继承带来的复杂性 6.4_函数式构建UI的实践</p><h2 id="第7章-修饰符-modifiers-的设计" tabindex="-1">第7章 修饰符（Modifiers）的设计 <a class="header-anchor" href="#第7章-修饰符-modifiers-的设计" aria-label="Permalink to &quot;第7章 修饰符（Modifiers）的设计&quot;">​</a></h2><p>7.1_修饰符返回一个新的视图 7.2_链式调用的实现原理 7.3_修饰符的顺序重要性 7.4_自定义修饰符的创建与使用</p><h2 id="第8章-布局系统设计" tabindex="-1">第8章 布局系统设计 <a class="header-anchor" href="#第8章-布局系统设计" aria-label="Permalink to &quot;第8章 布局系统设计&quot;">​</a></h2><p>8.1_容器视图（HStack, VStack, ZStack） 8.2_自适应布局与优先级 8.3_GeometryReader：获取父视图几何信息 8.4_布局中立性与跨平台适应</p><h2 id="第9章-视图身份-identity" tabindex="-1">第9章 视图身份（Identity） <a class="header-anchor" href="#第9章-视图身份-identity" aria-label="Permalink to &quot;第9章 视图身份（Identity）&quot;">​</a></h2><p>9.1_显式身份：id()修饰符的作用 9.2_结构性身份：基于视图在层级中的位置 9.3_身份对动画和过渡的影响 9.4_ForEach中身份的重要性</p><h2 id="第10章-性能优化设计" tabindex="-1">第10章 性能优化设计 <a class="header-anchor" href="#第10章-性能优化设计" aria-label="Permalink to &quot;第10章 性能优化设计&quot;">​</a></h2><p>10.1_视图差异比较（Diffing）算法 10.2_懒加载容器（Lazy Stacks &amp; Grids） 10.3_减少不必要的视图重绘 10.4_将计算密集型任务移出视图主体</p><h2 id="第11章-生命周期管理" tabindex="-1">第11章 生命周期管理 <a class="header-anchor" href="#第11章-生命周期管理" aria-label="Permalink to &quot;第11章 生命周期管理&quot;">​</a></h2><p>11.1_视图生命周期与状态生命周期的区别 11.2_onAppear和onDisappear修饰符 11.3_@StateObject的生命周期管理 11.4_任务（Task）修饰符与异步操作</p><h2 id="第12章-抽象与适配" tabindex="-1">第12章 抽象与适配 <a class="header-anchor" href="#第12章-抽象与适配" aria-label="Permalink to &quot;第12章 抽象与适配&quot;">​</a></h2><p>12.1_一套代码，多平台运行 12.2_平台特定控件的抽象化 12.3_使用#if os()进行平台条件编译 12.4_控件的自适应行为</p><h2 id="第13章-与原生框架的互操作性" tabindex="-1">第13章 与原生框架的互操作性 <a class="header-anchor" href="#第13章-与原生框架的互操作性" aria-label="Permalink to &quot;第13章 与原生框架的互操作性&quot;">​</a></h2><p>13.1_UIViewRepresentable协议 13.2_UIViewControllerRepresentable协议 13.3_NSViewRepresentable协议 13.4_在SwiftUI中嵌入UIKit-AppKit组件</p>',27)]))}const u=e(o,[["render",n]]);export{p as __pageData,u as default};
