import{_ as a,c as i,o as n,ag as l}from"./chunks/framework.Bw-5EFTY.js";const E=JSON.parse('{"title":"Animatable 协议与矢量动画","description":"","frontmatter":{},"headers":[],"relativePath":"core/11.3_Animatable 协议与矢量动画.md","filePath":"core/11.3_Animatable 协议与矢量动画.md"}'),e={name:"core/11.3_Animatable 协议与矢量动画.md"};function p(t,s,h,r,k,d){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="animatable-协议与矢量动画" tabindex="-1">Animatable 协议与矢量动画 <a class="header-anchor" href="#animatable-协议与矢量动画" aria-label="Permalink to &quot;Animatable 协议与矢量动画&quot;">​</a></h1><h2 id="animatable-协议-让你的-swiftui-视图动起来-🚀" tabindex="-1">Animatable 协议：让你的 SwiftUI 视图动起来！🚀 <a class="header-anchor" href="#animatable-协议-让你的-swiftui-视图动起来-🚀" aria-label="Permalink to &quot;Animatable 协议：让你的 SwiftUI 视图动起来！🚀&quot;">​</a></h2><p>想让你的 SwiftUI 视图拥有更高级、更流畅的动画效果吗？Animatable 协议就是你的秘密武器！它允许你控制视图属性如何随时间变化，从而创建出令人惊叹的矢量动画。准备好探索它的强大之处了吗？</p><p>Animatable 协议的核心在于 <code>animatableData</code> 属性。这个属性必须是符合 <code>VectorArithmetic</code> 协议的类型，例如 <code>Double</code>、<code>CGFloat</code> 或自定义的结构体。通过改变 <code>animatableData</code> 的值，SwiftUI 会自动驱动视图的动画。</p><ul><li><strong>简单易用</strong>: 只需要让你的视图符合 <code>Animatable</code> 协议，并提供 <code>animatableData</code> 属性。</li><li><strong>高度可定制</strong>: 你可以完全控制动画的每一个细节。</li><li><strong>性能优化</strong>: SwiftUI 会自动优化动画性能，确保流畅的体验。</li></ul><h2 id="创建自定义-animatable-形状-🎨" tabindex="-1">创建自定义 Animatable 形状 🎨 <a class="header-anchor" href="#创建自定义-animatable-形状-🎨" aria-label="Permalink to &quot;创建自定义 Animatable 形状 🎨&quot;">​</a></h2><p>让我们通过一个例子来深入理解。假设你想创建一个可以平滑改变边数的多边形。你可以定义一个 <code>Polygon</code> 结构体，并让它符合 <code>Animatable</code> 协议。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animatable </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sides: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animatableData: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { sides }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { sides </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... (计算多边形路径的代码) ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在这个例子中，<code>sides</code> 属性就是我们的 <code>animatableData</code>。当 <code>sides</code> 的值改变时，<code>path(in:)</code> 方法会被调用，从而更新多边形的形状。是不是很简单？🎉</p><h2 id="矢量动画的无限可能-💫" tabindex="-1">矢量动画的无限可能 💫 <a class="header-anchor" href="#矢量动画的无限可能-💫" aria-label="Permalink to &quot;矢量动画的无限可能 💫&quot;">​</a></h2><p>有了 Animatable 协议，你可以创造出各种各样的矢量动画。例如：</p><ol><li><strong>路径动画</strong>: 让形状沿着复杂的路径移动。</li><li><strong>变形动画</strong>: 平滑地改变形状的形态。</li><li><strong>渐变动画</strong>: 控制颜色的渐变过程。</li></ol><p>矢量动画相比于传统的位图动画，具有更高的清晰度和可缩放性。无论在什么分辨率下，都能保持完美的视觉效果。</p><h2 id="实战演练-制作一个动态加载指示器-⏳" tabindex="-1">实战演练：制作一个动态加载指示器 ⏳ <a class="header-anchor" href="#实战演练-制作一个动态加载指示器-⏳" aria-label="Permalink to &quot;实战演练：制作一个动态加载指示器 ⏳&quot;">​</a></h2><p>现在，让我们来做一个更实际的例子：一个动态加载指示器。我们可以使用 Animatable 协议来控制圆弧的起始角度和结束角度，从而模拟加载过程。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LoadingIndicator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animatable </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> progress: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animatableData: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { progress }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { progress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... (根据 progress 计算圆弧路径的代码) ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>通过不断改变 <code>progress</code> 的值，我们就可以让加载指示器动起来。是不是很有趣？ 🥳 记住，熟能生巧！多尝试、多实践，你就能掌握 Animatable 协议的精髓，创造出属于你自己的精彩动画！</p>`,17)]))}const o=a(e,[["render",p]]);export{E as __pageData,o as default};
