import{_ as s,c as a,o as t,ag as n}from"./chunks/framework.Bw-5EFTY.js";const g=JSON.parse('{"title":"处理认证与令牌 (Token)","description":"","frontmatter":{},"headers":[],"relativePath":"network/11.1_处理认证与令牌(Token).md","filePath":"network/11.1_处理认证与令牌(Token).md"}'),e={name:"network/11.1_处理认证与令牌(Token).md"};function r(l,i,o,h,p,k){return t(),a("div",null,i[0]||(i[0]=[n(`<h1 id="处理认证与令牌-token" tabindex="-1">处理认证与令牌 (Token) <a class="header-anchor" href="#处理认证与令牌-token" aria-label="Permalink to &quot;处理认证与令牌 (Token)&quot;">​</a></h1><p>在网络请求中，处理认证与令牌至关重要。令牌就像一把钥匙🔑，允许你的应用安全地访问受保护的资源。没有它，就像没有钥匙就想打开门一样，访问会被拒绝。</p><h2 id="令牌认证流程" tabindex="-1">令牌认证流程 <a class="header-anchor" href="#令牌认证流程" aria-label="Permalink to &quot;令牌认证流程&quot;">​</a></h2><p>令牌认证通常涉及以下步骤：</p><ol><li><strong>用户登录</strong>: 用户提供用户名和密码。</li><li><strong>服务器验证</strong>: 服务器验证用户凭据。</li><li><strong>颁发令牌</strong>: 如果验证成功，服务器会颁发一个令牌（例如，JWT）。</li><li><strong>存储令牌</strong>: 客户端（你的应用）安全地存储令牌。</li><li><strong>请求时携带令牌</strong>: 客户端在后续请求的头部中携带令牌（通常在 <code>Authorization</code> 头部）。</li><li><strong>服务器验证令牌</strong>: 服务器验证令牌的有效性。</li><li><strong>授权访问</strong>: 如果令牌有效，服务器授权访问请求的资源。</li></ol><h2 id="如何安全地存储令牌" tabindex="-1">如何安全地存储令牌 <a class="header-anchor" href="#如何安全地存储令牌" aria-label="Permalink to &quot;如何安全地存储令牌&quot;">​</a></h2><p>安全存储令牌至关重要，防止未经授权的访问。以下是一些建议：</p><ul><li><strong>Keychain</strong>: 使用 Keychain 来存储敏感信息，例如令牌。Keychain 提供了一个安全的存储区域，可以防止未经授权的访问。</li><li><strong>避免明文存储</strong>: 永远不要将令牌以明文形式存储在本地存储或用户默认设置中。</li><li><strong>加密</strong>: 如果必须将令牌存储在本地，请使用强加密算法对其进行加密。</li></ul><h2 id="在请求中添加令牌" tabindex="-1">在请求中添加令牌 <a class="header-anchor" href="#在请求中添加令牌" aria-label="Permalink to &quot;在请求中添加令牌&quot;">​</a></h2><p>在每个需要认证的请求中，你需要将令牌添加到请求头部。通常，这通过 <code>Authorization</code> 头部完成。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;你的令牌&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> headers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Authorization&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Bearer </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(token)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><strong>Bearer 方案</strong>: 使用 &quot;Bearer&quot; 方案是一种常见的做法，它告诉服务器这是一个 Bearer 令牌。</li><li><strong>拦截器</strong>: 你可以使用拦截器来自动将令牌添加到每个请求中，避免手动添加的麻烦。</li></ul><h2 id="错误处理与令牌失效" tabindex="-1">错误处理与令牌失效 <a class="header-anchor" href="#错误处理与令牌失效" aria-label="Permalink to &quot;错误处理与令牌失效&quot;">​</a></h2><p>当令牌失效时，服务器会返回一个错误。你需要处理这些错误，并采取适当的措施，例如：</p><ol><li><strong>检测错误</strong>: 检查服务器返回的错误代码（例如，401 Unauthorized）。</li><li><strong>刷新令牌</strong>: 如果你实现了刷新令牌机制，尝试刷新令牌。</li><li><strong>重新登录</strong>: 如果刷新令牌失败，提示用户重新登录。</li></ol><p>处理认证和令牌是构建安全可靠的SwiftUI应用的关键步骤。确保你理解这些概念，并采取适当的安全措施来保护用户数据。💪</p>`,16)]))}const c=s(e,[["render",r]]);export{g as __pageData,c as default};
