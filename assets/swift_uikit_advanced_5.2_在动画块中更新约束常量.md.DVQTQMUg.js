import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.ymCRTBvy.js";const E=JSON.parse('{"title":"在动画块中更新约束常量","description":"","frontmatter":{},"headers":[],"relativePath":"swift/uikit/advanced/5.2_在动画块中更新约束常量.md","filePath":"swift/uikit/advanced/5.2_在动画块中更新约束常量.md"}'),t={name:"swift/uikit/advanced/5.2_在动画块中更新约束常量.md"};function l(p,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="在动画块中更新约束常量" tabindex="-1">在动画块中更新约束常量 <a class="header-anchor" href="#在动画块中更新约束常量" aria-label="Permalink to &quot;在动画块中更新约束常量&quot;">​</a></h1><h2 id="动态调整约束的魅力-✨" tabindex="-1">动态调整约束的魅力 ✨ <a class="header-anchor" href="#动态调整约束的魅力-✨" aria-label="Permalink to &quot;动态调整约束的魅力 ✨&quot;">​</a></h2><p>在iOS开发中，用户界面的动态性是提升用户体验的关键。想象一下，一个按钮点击后平滑地移动到屏幕的另一个位置，或者一个视图在数据加载完成后优雅地扩展。这些效果都离不开对Auto Layout约束的动态更新，而将其包裹在动画块中，则能带来令人惊叹的视觉流畅度。</p><h2 id="为什么要在动画块中更新约束" tabindex="-1">为什么要在动画块中更新约束？ <a class="header-anchor" href="#为什么要在动画块中更新约束" aria-label="Permalink to &quot;为什么要在动画块中更新约束？&quot;">​</a></h2><p>直接修改约束的 <code>constant</code> 属性固然可以改变视图位置或大小，但如果不在动画块中执行，这些变化会瞬间发生，显得生硬且缺乏美感。将约束更新放入 <code>UIView.animate</code> 闭包中，系统会自动计算新旧状态之间的插值，并在指定的时间内平滑过渡。这就像给你的UI施加了魔法，让它变得生动起来！ 🪄</p><h2 id="实现步骤-更新约束常量并动画化" tabindex="-1">实现步骤：更新约束常量并动画化 <a class="header-anchor" href="#实现步骤-更新约束常量并动画化" aria-label="Permalink to &quot;实现步骤：更新约束常量并动画化&quot;">​</a></h2><p>要实现这一效果，你需要遵循几个简单的步骤。首先，确保你已经创建并激活了需要动态修改的约束。通常，我们会将这些约束存储为类的属性，以便后续访问。</p><ol><li><p><strong>创建并存储约束</strong>：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> topConstraint: NSLayoutConstraint</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ... 在 setupUI() 中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">topConstraint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myView.topAnchor.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equalTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: view.safeAreaLayoutGuide.topAnchor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">topConstraint.isActive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这样，<code>topConstraint</code> 就可以在任何时候被访问和修改了。</p></li><li><p><strong>在动画块中更新常量</strong>： 当某个事件触发时（例如按钮点击），你就可以在动画块中更新约束的 <code>constant</code> 值。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UIView.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">withDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.topConstraint.constant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 改变约束常量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">layoutIfNeeded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 强制布局更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>layoutIfNeeded()</code> 是一个至关重要的调用。它会强制父视图立即重新计算其子视图的布局。如果没有它，动画将不会发生，因为系统不会知道布局需要更新。</p></li></ol><h2 id="深入理解-layoutifneeded" tabindex="-1">深入理解 <code>layoutIfNeeded()</code> <a class="header-anchor" href="#深入理解-layoutifneeded" aria-label="Permalink to &quot;深入理解 \`layoutIfNeeded()\`&quot;">​</a></h2><p><code>layoutIfNeeded()</code> 方法告诉视图层级，所有待处理的布局操作都应该立即执行。当你在动画块中修改约束时，实际上是改变了视图的“目标”布局。<code>layoutIfNeeded()</code> 会在动画的每一帧中被调用，从而驱动视图从当前布局平滑地过渡到新的目标布局。这就像指挥一个交响乐团，确保所有乐器在正确的时间演奏正确的音符，共同创造出和谐的旋律。🎶</p><h2 id="动画选项与曲线" tabindex="-1">动画选项与曲线 <a class="header-anchor" href="#动画选项与曲线" aria-label="Permalink to &quot;动画选项与曲线&quot;">​</a></h2><p><code>UIView.animate</code> 方法提供了丰富的选项来定制你的动画效果。你可以调整动画时长 (<code>duration</code>)，设置延迟 (<code>delay</code>)，以及选择不同的动画曲线 (<code>options</code>)。例如，使用 <code>.curveEaseInOut</code> 可以让动画开始和结束时慢，中间快，提供更自然的视觉感受。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UIView.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">withDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .curveEaseInOut) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.topConstraint.constant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">layoutIfNeeded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { finished </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> finished {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;动画完成！🎉&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过这些选项，你可以创造出各种各样富有表现力的UI动画，让你的应用在众多产品中脱颖而出！根据统计，拥有流畅动画的应用用户留存率通常会高出15%左右。所以，大胆尝试，让你的UI动起来吧！</p>`,14)]))}const c=i(t,[["render",l]]);export{E as __pageData,c as default};
