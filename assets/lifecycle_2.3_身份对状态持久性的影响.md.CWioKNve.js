import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bw-5EFTY.js";const c=JSON.parse('{"title":"身份对状态持久性的影响","description":"","frontmatter":{},"headers":[],"relativePath":"lifecycle/2.3_身份对状态持久性的影响.md","filePath":"lifecycle/2.3_身份对状态持久性的影响.md"}'),e={name:"lifecycle/2.3_身份对状态持久性的影响.md"};function t(p,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="身份对状态持久性的影响" tabindex="-1">身份对状态持久性的影响 <a class="header-anchor" href="#身份对状态持久性的影响" aria-label="Permalink to &quot;身份对状态持久性的影响&quot;">​</a></h1><blockquote><p>在 SwiftUI 中，视图的身份（Identity）对于状态的持久性至关重要。当视图的身份保持不变时，即使视图的 <code>body</code> 发生了变化，其内部的状态也能够得以保留。这就像是你换了一件衣服，但你还是你，你的记忆和经验都还在。🎉</p></blockquote><h2 id="身份与状态的关联" tabindex="-1">身份与状态的关联 <a class="header-anchor" href="#身份与状态的关联" aria-label="Permalink to &quot;身份与状态的关联&quot;">​</a></h2><p>视图的身份决定了 SwiftUI 如何管理和更新视图的状态。如果 SwiftUI 认为两个视图具有相同的身份，它会尝试重用现有的视图实例，而不是创建一个新的实例。这意味着视图的状态，例如 <code>@State</code> 变量的值，会被保留下来。</p><ul><li>身份不变，状态保留。</li><li>身份改变，状态重置。</li></ul><h2 id="状态持久性的重要性" tabindex="-1">状态持久性的重要性 <a class="header-anchor" href="#状态持久性的重要性" aria-label="Permalink to &quot;状态持久性的重要性&quot;">​</a></h2><p>状态持久性对于构建流畅和响应迅速的 SwiftUI 应用至关重要。想象一下，如果每次视图更新都导致状态重置，那么用户在输入表单时，每次键盘弹出都会清空输入框的内容，这会非常糟糕。</p><p>以下是一些状态持久性的应用场景：</p><ol><li><strong>表单输入</strong>: 保持用户在文本框中的输入。</li><li><strong>滚动位置</strong>: 记住用户在列表中的滚动位置。</li><li><strong>动画状态</strong>: 维持动画的当前状态。</li></ol><h2 id="如何利用身份保持状态" tabindex="-1">如何利用身份保持状态 <a class="header-anchor" href="#如何利用身份保持状态" aria-label="Permalink to &quot;如何利用身份保持状态&quot;">​</a></h2><p>你可以通过以下方式来确保视图的身份在更新过程中保持不变：</p><ul><li><strong>使用 <code>.id()</code> 修饰符</strong>: 为视图显式地指定一个唯一的身份标识。例如，你可以使用数据的 <code>id</code> 属性作为视图的身份。</li><li><strong>保持视图在层级中的位置不变</strong>: 如果视图在视图层级中的位置发生变化，SwiftUI 可能会认为它是一个新的视图，从而导致状态重置。</li></ul><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id: UUID</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> View {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        TextField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Enter text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $text)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 id 保持身份</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="身份改变的影响" tabindex="-1">身份改变的影响 <a class="header-anchor" href="#身份改变的影响" aria-label="Permalink to &quot;身份改变的影响&quot;">​</a></h2><p>当视图的身份发生改变时，SwiftUI 会认为这是一个全新的视图，并创建一个新的视图实例。这意味着之前的状态会被丢弃，所有 <code>@State</code> 变量都会被重置为初始值。这就像是你被克隆了一个新的你，虽然外表一样，但记忆和经验都消失了。😱</p><ul><li>身份改变会导致状态丢失。</li><li>新的身份意味着新的开始。</li></ul><p>理解身份对状态持久性的影响，可以帮助你更好地管理 SwiftUI 视图的生命周期，并构建更稳定和用户友好的应用。记住，保持身份，留住状态！🚀</p>`,17)]))}const E=i(e,[["render",t]]);export{c as __pageData,E as default};
