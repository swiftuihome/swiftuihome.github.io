import{_ as e,c as i,o as t,ag as a}from"./chunks/framework.Bw-5EFTY.js";const u=JSON.parse('{"title":"第46天 项目 9 第四部分","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第46天_项目9_第四部分.md","filePath":"100days/第46天_项目9_第四部分.md"}'),l={name:"100days/第46天_项目9_第四部分.md"};function n(d,o,r,c,s,g){return t(),i("div",null,o[0]||(o[0]=[a('<h1 id="第46天-项目-9-第四部分" tabindex="-1">第46天 项目 9 第四部分 <a class="header-anchor" href="#第46天-项目-9-第四部分" aria-label="Permalink to &quot;第46天 项目 9 第四部分&quot;">​</a></h1><p>又一个项目完成了，到目前为止，你已经初步接触了SwiftUI几乎所有的导航API。你很可能想马上回到应用开发中，但请花点时间停下来回顾一下所学内容——也许在一段时间内你不会用到所有这些知识，但重要的是你至少要记住学过了什么，以便之后可以回头查阅。</p><p>所以，今天你还有一次复习来检验自己的记忆，另外还有一些挑战让你自己动手编码。和往常一样，这些挑战我不会提供解决方案，但这正是关键所在——正如美国国家橄榄球联盟（NFL）球员特洛伊·波拉马鲁曾经说过的：“我一直认为，没有人能比我自己更能挑战我。”</p><p>你可以用任何你喜欢的方式、在任何你方便的时间来解决这些挑战，也许你能毫无困难地完成。另一方面，或许在解决过程中，你会发现自己某些知识掌握得还不够扎实——只有尝试过，你才能知道问题所在。</p><p>今天你应该完成第9个项目的总结章节，完成相关复习，然后攻克所有三个挑战。</p><ul><li>导航：总结</li><li>第9个项目复习：导航</li></ul><h2 id="导航-总结" tabindex="-1">导航：总结 <a class="header-anchor" href="#导航-总结" aria-label="Permalink to &quot;导航：总结&quot;">​</a></h2><p><em>作者：Paul Hudson 2023年11月2日</em></p><p>我希望这个技术项目能让你在SwiftUI导航方面更有信心，因为导航几乎是你将要构建的每一个应用的核心。</p><p>诚然，像<code>Hashable</code>这样的部分起初可能不是完全易懂，但目前你真正需要知道的是它是一项必需的协议——当我们使用结构体时，Swift可以为我们完成大部分工作，所以通常只需添加<code>Hashable</code>、<code>Codable</code>和<code>Equatable</code>这类协议就足够了。</p><p>之后我们会学习另一种更适合大屏幕设备的导航方式，但目前你已经完成了本部分的学习——做得很好！</p><h2 id="回顾所学内容" tabindex="-1">回顾所学内容 <a class="header-anchor" href="#回顾所学内容" aria-label="Permalink to &quot;回顾所学内容&quot;">​</a></h2><p>任何人都能看完一个教程，但要记住所学的知识则需要实际付出努力。确保你能从这些教程中收获尽可能多的知识是我的职责，完成后面的练习题可以帮助你检验学习成果。</p><h2 id="挑战" tabindex="-1">挑战 <a class="header-anchor" href="#挑战" aria-label="Permalink to &quot;挑战&quot;">​</a></h2><p>学习编程最好的方法之一就是尽可能多地自己编写代码，因此我准备了三个拓展本应用的方向，帮助你确保完全理解所学内容。</p><ol><li>修改第7个项目（iExpense），使其使用<code>NavigationLink</code>添加新支出项，而不是使用工作表（sheet）。（提示：<code>dismiss()</code>代码在这里非常好用，但你可能需要添加<code>navigationBarBackButtonHidden()</code>修饰符，这样用户就必须明确选择“取消”。）</li><li>尝试修改第7个项目，让用户可以在导航标题中编辑支出项名称，而不是在单独的文本框中编辑。你更喜欢哪种方式？</li><li>回到第8个项目（Moonshot），将其升级为使用<code>NavigationLink(value:)</code>。这意味着需要添加<code>Hashable</code>协议遵循，并且要仔细思考如何使用<code>navigationDestination()</code>。</li></ol><h2 id="【练习题】导航" tabindex="-1">【练习题】导航 <a class="header-anchor" href="#【练习题】导航" aria-label="Permalink to &quot;【练习题】导航&quot;">​</a></h2><p>问题1/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：结构体要与<code>NavigationLink</code>配合使用，必须遵循<code>Hashable</code>协议。</li><li><strong>选项2</strong>：结构体要与<code>NavigationLink</code>配合使用，必须遵循<code>Codable</code>协议。</li></ul><p>问题2/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：要指定工具栏按钮的位置，我们需要使用<code>ToolbarItem</code>或<code>ToolbarItemGroup</code>。</li><li><strong>选项2</strong>：当用户导航到详情页面时，返回（Back）按钮必须始终可见。</li></ul><p>问题3/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：在列表行（list rows）中使用<code>NavigationLink</code>时，SwiftUI会自动在 trailing 边缘添加展开箭头（disclosure chevrons）。</li><li><strong>选项2</strong>：用户始终可以编辑你的导航标题。</li></ul><p>问题4/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：我们可以使用<code>NavigationLink</code>或工作表（sheets），但不能两者同时使用。</li><li><strong>选项2</strong>：<code>NavigationPath</code>是跟踪包含多种不同数据类型的路径的最佳方式</li></ul><p>问题5/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：<code>@Binding</code>属性包装器允许我们与另一个视图共享<code>@State</code>属性。</li><li><strong>选项2</strong>：你应该始终为工具栏按钮指定确切的位置。</li></ul><p>问题6/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：隐藏导航栏会禁用向导航栈中推入视图（pushing views onto the stack）的功能。</li><li><strong>选项2</strong>：如果结构体的所有属性都遵循<code>Hashable</code>协议，Swift可以让该结构体自动遵循<code>Hashable</code>协议。</li></ul><p>问题7/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：我们可以使用<code>.toolbar(.hidden, for: .navigationBar)</code>来隐藏导航栏。</li><li><strong>选项2</strong>：使用多个<code>navigationDestination()</code>修饰符是个糟糕的主意。</li></ul><p>问题8/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：将导航路径绑定到某个状态时，我们可以使用<code>didSet</code>属性观察器来检测路径的变化。</li><li><strong>选项2</strong>：将值绑定到<code>NavigationStack</code>的路径时，该值必须放在一个单独的类中。</li></ul><p>问题9/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：如果我们使用<code>NavigationPath</code>，就无法保存用户当前的导航路径。</li><li><strong>选项2</strong>：只有当导航栏处于<code>.inline</code>显示模式时，才能启用用户可编辑的导航标题。</li></ul><p>问题10/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：可以使用<code>toolbarColorScheme()</code>修饰符调整<code>NavigationStack</code>中标题文本的颜色。</li><li><strong>选项2</strong>：如果需要返回到<code>NavigationStack</code>的根视图，我们需要调用它的<code>popToRootView()</code>方法。</li></ul><p>问题11/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：SwiftUI允许我们自定义导航栏的背景颜色。</li><li><strong>选项2</strong>：每个<code>NavigationLink</code>都必须有标题文本。</li></ul><p>问题12/12：以下哪些陈述是正确的？</p><ul><li><strong>选项1</strong>：SwiftUI既可以导航到自定义视图，也可以导航到<code>Text</code>和<code>Color</code>等内置视图。</li><li><strong>选项2</strong>：尽可能隐藏导航栏是个好主意。</li></ul>',41)]))}const h=e(l,[["render",n]]);export{u as __pageData,h as default};
