import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.ymCRTBvy.js";const E=JSON.parse('{"title":"7.3_理解视图布局的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"swift/uikit/basics/7.3_理解视图布局的生命周期.md","filePath":"swift/uikit/basics/7.3_理解视图布局的生命周期.md"}'),t={name:"swift/uikit/basics/7.3_理解视图布局的生命周期.md"};function l(h,s,p,k,d,r){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="_7-3-理解视图布局的生命周期" tabindex="-1">7.3_理解视图布局的生命周期 <a class="header-anchor" href="#_7-3-理解视图布局的生命周期" aria-label="Permalink to &quot;7.3_理解视图布局的生命周期&quot;">​</a></h1><h2 id="视图布局生命周期详解-📱" tabindex="-1">视图布局生命周期详解 📱 <a class="header-anchor" href="#视图布局生命周期详解-📱" aria-label="Permalink to &quot;视图布局生命周期详解 📱&quot;">​</a></h2><p>视图的布局生命周期是理解 iOS 应用界面如何渲染的关键。它涉及到一系列自动发生的步骤，确保你的视图在屏幕上正确显示。掌握这些步骤，你就能更好地控制视图的外观和行为。让我们一起深入了解吧！🎉</p><h2 id="布局更新的触发" tabindex="-1">布局更新的触发 <a class="header-anchor" href="#布局更新的触发" aria-label="Permalink to &quot;布局更新的触发&quot;">​</a></h2><p>布局更新并非随意发生，而是由特定事件触发。当你修改视图的约束（constraints）时，系统会标记该视图需要重新布局。此外，改变视图的 <code>frame</code> 也会触发布局更新。系统会尽可能地将多个布局更新合并到一起，以提高性能。</p><ul><li>修改约束</li><li>改变 <code>frame</code></li><li>滚动视图</li><li>设备旋转</li></ul><h2 id="布局更新的阶段-🔄" tabindex="-1">布局更新的阶段 🔄 <a class="header-anchor" href="#布局更新的阶段-🔄" aria-label="Permalink to &quot;布局更新的阶段 🔄&quot;">​</a></h2><p>布局更新过程分为三个主要阶段，每个阶段都有特定的任务：</p><ol><li><p><strong>更新约束（Update Constraints）</strong>: 在这个阶段，系统会根据视图的约束条件计算视图的 <code>frame</code>。你可以重写 <code>updateConstraints()</code> 方法来添加或修改约束。这是一个非常重要的步骤，确保你的视图按照预期的方式进行布局。</p></li><li><p><strong>布局（Layout）</strong>: 在这个阶段，系统会根据计算出的 <code>frame</code> 来设置视图的位置和大小。你可以重写 <code>layoutSubviews()</code> 方法来自定义子视图的布局。这是你控制视图外观的主要机会。</p></li><li><p><strong>显示（Display）</strong>: 在这个阶段，系统会绘制视图的内容。你可以重写 <code>draw(_ rect: CGRect)</code> 方法来自定义视图的绘制。这个阶段主要关注视图的视觉呈现。</p></li></ol><h2 id="setneedslayout-和-layoutifneeded-🛠️" tabindex="-1"><code>setNeedsLayout()</code> 和 <code>layoutIfNeeded()</code> 🛠️ <a class="header-anchor" href="#setneedslayout-和-layoutifneeded-🛠️" aria-label="Permalink to &quot;\`setNeedsLayout()\` 和 \`layoutIfNeeded()\` 🛠️&quot;">​</a></h2><p><code>setNeedsLayout()</code> 方法告诉系统，该视图需要在下一个布局周期进行更新。它不会立即触发布局更新，而是将更新请求加入队列。<code>layoutIfNeeded()</code> 方法会立即触发布局更新，如果视图需要更新的话。</p><ul><li><code>setNeedsLayout()</code>：异步更新</li><li><code>layoutIfNeeded()</code>：同步更新</li></ul><p>选择哪个方法取决于你的需求。如果你想立即看到布局更新的结果，可以使用 <code>layoutIfNeeded()</code>。如果你想让系统在适当的时候进行更新，可以使用 <code>setNeedsLayout()</code>。</p><h2 id="示例-自定义视图布局-🎨" tabindex="-1">示例：自定义视图布局 🎨 <a class="header-anchor" href="#示例-自定义视图布局-🎨" aria-label="Permalink to &quot;示例：自定义视图布局 🎨&quot;">​</a></h2><p>假设你有一个自定义视图，其中包含一个标签和一个按钮。你可以重写 <code>layoutSubviews()</code> 方法来设置标签和按钮的位置。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> layoutSubviews</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">layoutSubviews</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置标签的位置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label.frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CGRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: bounds.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置按钮的位置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    button.frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CGRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: label.frame.maxY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: bounds.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>通过重写 <code>layoutSubviews()</code> 方法，你可以完全控制子视图的布局。这为你提供了极大的灵活性，可以创建各种各样的自定义界面。</p><h2 id="总结-📝" tabindex="-1">总结 📝 <a class="header-anchor" href="#总结-📝" aria-label="Permalink to &quot;总结 📝&quot;">​</a></h2><p>理解视图布局的生命周期对于创建高质量的 iOS 应用至关重要。通过掌握布局更新的触发、阶段以及相关方法，你可以更好地控制视图的外观和行为。希望你能充分利用这些知识，创造出令人惊艳的应用界面！🚀</p>`,19)]))}const c=i(t,[["render",l]]);export{E as __pageData,c as default};
