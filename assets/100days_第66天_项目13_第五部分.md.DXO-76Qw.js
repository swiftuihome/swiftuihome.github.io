import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.Bw-5EFTY.js";const o=JSON.parse('{"title":"第66天 项目 13 第五部分","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第66天_项目13_第五部分.md","filePath":"100days/第66天_项目13_第五部分.md"}'),t={name:"100days/第66天_项目13_第五部分.md"};function p(l,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="第66天-项目-13-第五部分" tabindex="-1">第66天 项目 13 第五部分 <a class="header-anchor" href="#第66天-项目-13-第五部分" aria-label="Permalink to &quot;第66天 项目 13 第五部分&quot;">​</a></h1><p>现在是为我们的应用程序进行最后润色的时候了，这款应用将允许用户尝试不同的Core Image滤镜，然后与其他应用程序分享处理结果。</p><p>今天的工作需要我们回顾之前遇到的一些Core Image问题，即Core Image中那种往好里说也只能算怪异的“字符串类型化”API。这里很容易出错，所以请慢慢操作，将你的代码与我的代码仔细核对，并记住莫舍软件工程定律：“如果程序运行不正常，别担心——要是一切都正常，你就该失业了。”</p><p><strong>今天你需要完成两个主题的内容，在这些内容中，你将实践确认对话框、<code>ShareLink</code>等功能。</strong></p><ul><li>使用confirmationDialog()自定义滤镜</li><li>使用ShareLink分享图片</li></ul><p>又一个应用程序完成了——别忘了向全世界分享你的进展！</p><h2 id="使用confirmationdialog-自定义滤镜" tabindex="-1">使用confirmationDialog()自定义滤镜 <a class="header-anchor" href="#使用confirmationdialog-自定义滤镜" aria-label="Permalink to &quot;使用confirmationDialog()自定义滤镜&quot;">​</a></h2><p>作者：Paul Hudson 2023年12月12日</p><p>到目前为止，我们已经将SwiftUI和Core Image整合到了一起，但这款应用仍然不是特别实用——毕竟，棕褐色调效果并没有那么有趣。</p><p>为了让整个应用变得更好，我们打算让用户能够自定义想要应用的滤镜，而我们将通过确认对话框来实现这一点。在iPhone上，确认对话框是从屏幕底部滑上来的一系列按钮，你可以根据需要添加任意多个按钮——如果确实需要，它甚至可以滚动。</p><p>首先，我们需要一个属性来存储确认对话框是否应该显示，所以在<code>ContentView</code>中添加以下代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> showingFilters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>现在，我们可以使用<code>confirmationDialog()</code>修饰符添加按钮了。它的工作方式与<code>alert()</code>完全相同：我们提供一个标题和一个要监听的条件，一旦条件变为true，确认对话框就会显示出来。</p><p>首先，在导航标题下方添加这个修饰符：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">confirmationDialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;选择滤镜&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isPresented</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: $showingFilters) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 对话框内容放在这里</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接下来，用以下代码填充<code>changeFilter()</code>方法：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">showingFilters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>至于在确认对话框中显示什么内容，我们可以创建一系列要显示的按钮以及一条可选消息。这些按钮的使用方式与<code>alert()</code>中的按钮类似：我们提供一个文本标题和一个点击按钮时要执行的操作。</p><p>在这款应用的确认对话框中，我们希望用户能从一系列不同的Core Image滤镜中进行选择，当他们选择某个滤镜后，该滤镜应立即被激活并应用。为了实现这一点，我们将编写一个方法，该方法会将<code>currentFilter</code>修改为用户选择的新滤镜，然后立即调用<code>loadImage()</code>。</p><p>不过，我们的计划中存在一个小问题，这是苹果为了让Core Image API更符合Swift风格而进行封装所导致的。要知道，底层的Core Image API完全是“字符串类型化”的——它使用字符串来设置值，而不是使用固定的属性——因此，苹果没有为我们创建全新的类，而是创建了一系列协议。</p><p>当我们将<code>CIFilter.sepiaTone()</code>赋值给一个属性时，会得到一个<code>CIFilter</code>类的对象，该对象恰好遵循名为<code>CISepiaTone</code>的协议。这个协议随后会暴露我们一直在使用的<code>intensity</code>参数，但在内部，它实际上只是将该参数映射为对<code>setValue(_:forKey:)</code>方法的调用。</p><p>这种灵活性实际上对我们有利，因为它意味着只要我们小心避免传入无效值，就能编写出适用于所有滤镜的代码。</p><p>那么，让我们开始解决这个问题吧。请将你的<code>currentFilter</code>属性修改为以下代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@State</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentFilter: CIFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sepiaTone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>再次说明，<code>CIFilter.sepiaTone()</code>会返回一个<code>CIFilter</code>对象，该对象遵循<code>CISepiaTone</code>协议。添加这个显式的类型注解意味着我们会丢失一些数据：我们指定该滤镜必须是<code>CIFilter</code>类型，但不再要求它必须遵循<code>CISepiaTone</code>协议。</p><p>由于这个修改，我们无法再访问<code>intensity</code>属性了，这就导致以下代码无法正常工作：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentFilter.intensity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filterIntensity)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>相反，我们需要用对<code>setValue(_:forKey:)</code>方法的调用来替换这行代码。实际上，之前的协议所做的工作本质上也是如此，但协议还提供了宝贵的额外类型安全性。</p><p>用以下代码替换那行无法正常工作的代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filterIntensity, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: kCIInputIntensityKey)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>kCIInputIntensityKey</code>是另一个Core Image常量值，它的作用与设置棕褐色调滤镜的<code>intensity</code>参数相同。</p><p>完成这个修改后，我们可以回到确认对话框的实现上：我们希望能够将滤镜修改为其他类型，然后调用<code>loadImage()</code>来重置所有内容并应用初始处理。因此，在<code>ContentView</code>中添加以下方法：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter: CIFilter) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    currentFilter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    loadImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>提示：</strong> 这意味着每次滤镜更改时都会触发图像加载。如果你想让这个过程运行得更快一些，可以将<code>beginImage</code>存储在另一个<code>@State</code>属性中，这样就不必每次更改滤镜时都重新加载图像了。</p><p>完成上述操作后，我们就可以用一系列按钮替换<code>// 对话框内容放在这里</code>这个注释了，这些按钮对应着各种不同的Core Image滤镜。</p><p>将以下代码放在注释所在的位置：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;结晶效果（Crystallize）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">crystallize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;边缘检测（Edges）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">edges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;高斯模糊（Gaussian Blur）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gaussianBlur</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;像素化（Pixellate）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pixellate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;棕褐色调（Sepia Tone）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sepiaTone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;锐化蒙版（Unsharp Mask）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unsharpMask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;晕影（Vignette）&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CIFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vignette</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;取消&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">role</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: .cancel) { }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这些滤镜是我从众多Core Image滤镜中挑选出来的，不过你也可以尝试使用代码补全功能来尝试其他滤镜——输入<code>CIFilter.</code>，看看会出现哪些选项！</p><p>现在运行应用程序，选择一张图片，然后尝试将“棕褐色调”滤镜切换为“晕影”滤镜——这会在照片边缘周围产生变暗效果。（如果你使用的是模拟器，请记住给它一点时间，因为模拟器运行速度较慢！）</p><p>接下来尝试将滤镜切换为“高斯模糊”，理论上它应该会使图像模糊，但实际上却会导致应用程序崩溃。由于我们不再对滤镜施加<code>CISepiaTone</code>协议的限制，现在不得不使用<code>setValue(_:forKey:)</code>方法来传入值，而这种方式完全没有安全性可言。在这个例子中，高斯模糊滤镜没有“强度（intensity）”值，所以应用程序就直接崩溃了。</p><p>为了解决这个问题——同时也为了让我们的单个滑块能发挥更多作用——我们将添加一些额外的代码，这些代码会读取所有可用于<code>setValue(_:forKey:)</code>方法的有效键，并且只在当前滤镜支持“强度”键时才设置该键的值。通过这种方法，我们实际上可以查询任意多个键，并设置所有受支持的键。例如，对于棕褐色调滤镜，这会设置“强度（intensity）”值；而对于高斯模糊滤镜，这会设置“半径（radius，模糊程度）”值，依此类推。</p><p>这种条件判断的方法适用于你选择应用的任何滤镜，这意味着你可以安全地尝试其他滤镜。你只需要注意确保将<code>filterIntensity</code>乘以一个合理的数值——例如，1像素的模糊效果几乎是看不见的，所以我打算将它乘以200，使其效果更明显。</p><p>用以下代码替换这行代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filterIntensity, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: kCIInputIntensityKey)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>替换后的代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputKeys </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentFilter.inputKeys</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputKeys.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kCIInputIntensityKey) { currentFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filterIntensity, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: kCIInputIntensityKey) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputKeys.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kCIInputRadiusKey) { currentFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filterIntensity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: kCIInputRadiusKey) }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputKeys.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(kCIInputScaleKey) { currentFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filterIntensity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: kCIInputScaleKey) }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>完成这个修改后，你现在就可以安全地运行应用程序了。导入一张你选择的图片，然后尝试使用所有不同的滤镜——现在应该不会再出现崩溃的情况了。尝试使用不同的滤镜和键，看看你能发现什么新效果！</p><h2 id="使用sharelink分享图片" tabindex="-1">使用ShareLink分享图片 <a class="header-anchor" href="#使用sharelink分享图片" aria-label="Permalink to &quot;使用ShareLink分享图片&quot;">​</a></h2><p>作者：Paul Hudson 2023年12月12日</p><p>要完成这个项目，我们还需要添加两个重要功能：让用户能够使用SwiftUI的<code>ShareLink</code>视图分享他们的图片，然后在适当的时间过后，提示用户到App Store上为我们的应用程序评分。</p><p>这两个功能都不算复杂，所以让我们直接开始编写代码吧。</p><p>SwiftUI的<code>ShareLink</code>按钮能让我们只需一行代码就能分享文本、URL和图片等内容，它会自动处理系统标准的分享面板，让用户看到所有支持我们所分享数据的应用程序。</p><p>在我们的项目中，已经有一个<code>// 分享图片</code>的注释，但我们需要将其替换为一段检查代码：先检查是否有可分享的图片，如果有的话，就创建一个用于分享该图片的<code>ShareLink</code>按钮。</p><p>用以下代码替换该注释：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> processedImage {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ShareLink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: processedImage, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">preview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SharePreview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Instafilter图片&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: processedImage))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样，第一步就完成了。不过请记住，要在真实设备上进行测试，这样你才能看到各种真实应用程序对该图片的响应情况。</p><p>现在，只剩下最后一步了：请求用户为我们的应用程序评分。记住，最好只在用户真正感受到应用程序的价值之后再显示评分请求，因为如果请求过早，用户很可能会忽略它。</p><p>因此，我们不会“总是”显示评分请求，而是会等到用户至少更改过20次滤镜后再显示——这个次数足以让用户多次尝试所有选项，所以他们很可能会愿意帮忙评分。</p><p>首先，我们需要添加两个新属性：一个用于从SwiftUI的环境中获取评分请求器，另一个用于跟踪滤镜更改的次数。首先在ContentView.swift文件中再添加一个导入语句，导入StoreKit框架，然后在<code>ContentView</code>中添加以下两个属性：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@AppStorage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filterCount&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(\\.requestReview) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> requestReview</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接下来，我们需要在<code>setFilter()</code>方法的末尾添加一些代码，以便在每次滤镜更改时将<code>filterCount</code>加1，然后在滤镜更改次数至少达到20次时触发评分请求。将以下代码放在该方法的末尾：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filterCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    requestReview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这会在Xcode中触发一个错误：评分请求必须在Swift的主actor（主线程相关的执行体）上进行，主actor是我们应用程序中能够处理用户界面操作的部分。虽然我们当前是在SwiftUI视图内部编写代码，但Swift无法保证这段代码会在主actor上运行，除非我们明确强制它这样做。</p><p>听起来好像很复杂，但实际上只需将该方法修改为以下形式即可：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@MainActor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter: CIFilter) {</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>现在，Swift会确保这段代码始终在主actor上运行，编译错误也会随之消失。</p><p><strong>提示：</strong> 为了测试方便，你或许可以将评分请求的条件从20次修改为5次左右，这样就能确保你的代码按预期工作了！</p><p>这最后一步完成后，我们的应用程序就全部开发完成了。现在再次运行应用程序，从头到尾尝试一遍——导入图片、应用滤镜，然后将图片分享到其他应用程序。做得好！</p>`,68)]))}const c=i(t,[["render",p]]);export{o as __pageData,c as default};
