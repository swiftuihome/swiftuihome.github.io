import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"定义子视图控制器的视图frame","description":"","frontmatter":{},"headers":[],"relativePath":"swift/uikit/advanced/15.3_定义子视图控制器的视图frame.md","filePath":"swift/uikit/advanced/15.3_定义子视图控制器的视图frame.md"}'),h={name:"swift/uikit/advanced/15.3_定义子视图控制器的视图frame.md"};function l(t,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="定义子视图控制器的视图frame" tabindex="-1">定义子视图控制器的视图frame <a class="header-anchor" href="#定义子视图控制器的视图frame" aria-label="Permalink to &quot;定义子视图控制器的视图frame&quot;">​</a></h1><h2 id="理解视图层级与布局" tabindex="-1">理解视图层级与布局 <a class="header-anchor" href="#理解视图层级与布局" aria-label="Permalink to &quot;理解视图层级与布局&quot;">​</a></h2><p>在自定义容器视图控制器中，精确地定义子视图控制器的视图 <code>frame</code> 至关重要。这就像为你的子视图在父视图中划定专属的“地盘”一样。如果 <code>frame</code> 设置不当，子视图可能会显示不全，或者与父视图的布局发生冲突。 📏</p><p>想象一下，你正在设计一个仪表盘应用，其中包含多个小部件（子视图控制器）。每个小部件都需要在主屏幕上占据一个特定的区域。正确设置它们的 <code>frame</code> 就能确保它们各司其职，互不干扰。</p><h2 id="设置子视图的初始frame" tabindex="-1">设置子视图的初始Frame <a class="header-anchor" href="#设置子视图的初始frame" aria-label="Permalink to &quot;设置子视图的初始Frame&quot;">​</a></h2><p>当你将一个子视图控制器添加到容器视图控制器时，它的视图并不会自动获得一个 <code>frame</code>。你需要手动为其指定。通常，这会在 <code>addChild</code> 方法调用之后进行。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 childVC 是你的子视图控制器</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childVC)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">containerView.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addSubview</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> containerView.bounds </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例：让子视图填充整个容器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">didMove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">toParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里，<code>containerView.bounds</code> 是一个常见的起点，它让子视图的视图完全覆盖容器视图。然而，你也可以根据具体需求设置更复杂的 <code>frame</code>。例如，你可能希望子视图只占据容器视图的顶部一半。</p><h2 id="动态调整子视图frame" tabindex="-1">动态调整子视图Frame <a class="header-anchor" href="#动态调整子视图frame" aria-label="Permalink to &quot;动态调整子视图Frame&quot;">​</a></h2><p>应用程序的布局并非一成不变。当设备旋转、父视图大小改变或用户交互触发时，子视图的 <code>frame</code> 可能需要动态调整。这通常在容器视图控制器的 <code>viewDidLayoutSubviews()</code> 方法中完成。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> viewDidLayoutSubviews</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viewDidLayoutSubviews</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 假设 childVC 是你的子视图控制器</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 示例：让子视图始终占据容器视图的左上角100x100区域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CGRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在 <code>viewDidLayoutSubviews()</code> 中调整 <code>frame</code> 可以确保子视图的布局始终与容器视图的当前状态保持同步。这是一个非常强大的机制，可以应对各种复杂的布局需求。 🔄</p><h2 id="考虑安全区域与边距" tabindex="-1">考虑安全区域与边距 <a class="header-anchor" href="#考虑安全区域与边距" aria-label="Permalink to &quot;考虑安全区域与边距&quot;">​</a></h2><p>在 iOS 11 及更高版本中，<code>safeAreaInsets</code> 变得非常重要。它们定义了视图中不被导航栏、标签栏或设备刘海等系统元素遮挡的区域。在设置子视图 <code>frame</code> 时，你可能需要考虑这些安全区域。</p><p>例如，如果你希望子视图的顶部与安全区域的顶部对齐，你可以这样做：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> safeArea </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> view.safeAreaLayoutGuide</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CGRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: safeArea.layoutFrame.origin.x,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: safeArea.layoutFrame.origin.y,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: safeArea.layoutFrame.width,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: safeArea.layoutFrame.height</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这确保了你的子视图内容不会被系统UI元素遮挡，提供了更好的用户体验。 📱</p><h2 id="使用auto-layout进行更灵活的布局" tabindex="-1">使用Auto Layout进行更灵活的布局 <a class="header-anchor" href="#使用auto-layout进行更灵活的布局" aria-label="Permalink to &quot;使用Auto Layout进行更灵活的布局&quot;">​</a></h2><p>虽然直接设置 <code>frame</code> 对于简单的布局非常有效，但对于更复杂的、响应式的布局，你可能会发现 Auto Layout 更加强大和灵活。你可以通过设置约束来定义子视图相对于父视图或其他兄弟视图的位置和大小。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.translatesAutoresizingMaskIntoConstraints </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 禁用AutoresizingMask</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NSLayoutConstraint.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">activate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.topAnchor.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equalTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: view.safeAreaLayoutGuide.topAnchor),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.leadingAnchor.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equalTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: view.leadingAnchor),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.widthAnchor.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equalToConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childVC.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heightAnchor.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equalToConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">150</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用 Auto Layout 可以让你声明式地定义布局规则，系统会根据这些规则自动计算 <code>frame</code>。这大大简化了在不同屏幕尺寸和方向下维护布局的复杂性。 🚀 事实上，超过 80% 的 iOS 开发者在处理复杂布局时会选择 Auto Layout，因为它能显著减少手动计算 <code>frame</code> 的工作量。</p>`,21)]))}const o=i(h,[["render",l]]);export{c as __pageData,o as default};
