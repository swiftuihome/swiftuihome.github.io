import{_ as t,c as e,o,ag as d}from"./chunks/framework.Bw-5EFTY.js";const l=JSON.parse('{"title":"第61天 SwiftData 时间","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第61天_SwiftData时间.md","filePath":"100days/第61天_SwiftData时间.md"}'),r={name:"100days/第61天_SwiftData时间.md"};function i(p,a,s,c,n,_){return o(),e("div",null,a[0]||(a[0]=[d('<h1 id="第61天-swiftdata-时间" tabindex="-1">第61天 SwiftData 时间 <a class="header-anchor" href="#第61天-swiftdata-时间" aria-label="Permalink to &quot;第61天 SwiftData 时间&quot;">​</a></h1><p>如果我之前告诉你，你的任务是开发一个应用，要求从网络获取数据、将其解码为原生Swift类型，然后使用导航栈进行展示——哦，对了，整个过程还得用SwiftData来驱动……坦白说，你很可能会对这个任务望而却步。</p><p>所以，我换了个方式：昨天已经让你完成了这个应用的基础部分，确保你理解JSON数据结构、正确实现了Codable支持、梳理好了UI设计思路等等。</p><p>而<strong>今天</strong>，我要做一件在任何实际项目中都难免会发生的事：给这个项目的范围增加一个新的功能需求。这种情况有时被称为“范围蔓延”，几乎在你参与的每一个项目中都可能遇到。但这并不意味着提前规划没有意义——就像温斯顿·丘吉尔说过的：“制定计划的人比不制定计划的人做得更好，即便他们很少能完全按计划行事。”</p><p>所以，我们不会严格按原计划进行；我们要新增一个重要功能，这个功能会迫使你重新思考之前构建应用的方式，有望让你反思代码的结构设计，同时还能让你练习一项如今必须熟练掌握的技术：SwiftData。</p><p>没错，你今天的任务就是扩展你的应用，使其支持SwiftData。你的上司刚刚发邮件说，这个应用整体不错，但希望在JSON数据下载完成后，应用能<strong>支持离线使用</strong>。这意味着你需要用SwiftData存储下载到的信息，然后通过SwiftData模型来展示你之前设计的视图——数据只需获取一次即可。</p><p>最终呈现的效果，理应和我一开始就把完整任务交给你所达成的效果一致。但像这样把任务拆分成两部分来完成，希望能让它看起来更容易实现，同时也能让你有机会思考：自己的代码结构是否足够灵活，能否应对后续的需求变更。</p><h2 id="重要提示-请务必阅读" tabindex="-1">重要提示：请务必阅读！ <a class="header-anchor" href="#重要提示-请务必阅读" aria-label="Permalink to &quot;重要提示：请务必阅读！&quot;">​</a></h2><p><strong>这是一项有难度的挑战。</strong> 下面我会给一个小提示，有些人可能会想：“提示？哈！我不需要提示，我自己能搞定！”但今天请破例听一下这个提示，因为它能帮你节省好几个小时的麻烦。</p><p>提示如下：你需要将<code>User</code>和<code>Friend</code>结构体改成遵循<code>Codable</code>协议的<code>@Model</code>类。要实现这一点，就需要自定义Codable协议的实现：包括一个从<code>Decoder</code>初始化的构造器，以及一个<code>encode(to:)</code>方法。</p><p>如果已经忘记该如何操作，可以重新阅读最近一个里程碑的【重点内容】总结，尤其是“完全自定义Codable实现”那一部分。</p><p>提示就这些！再次强调，这是一项有难度的挑战，所以当你觉得困难时，不必感到沮丧。慢慢来，一步一步解决问题就好。</p><p>祝你好运！</p>',13)]))}const S=t(r,[["render",i]]);export{l as __pageData,S as default};
