import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.ymCRTBvy.js";const c=JSON.parse('{"title":"避免深度继承带来的复杂性","description":"","frontmatter":{},"headers":[],"relativePath":"thinking/6.3_避免深度继承带来的复杂性.md","filePath":"thinking/6.3_避免深度继承带来的复杂性.md"}'),e={name:"thinking/6.3_避免深度继承带来的复杂性.md"};function p(t,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="避免深度继承带来的复杂性" tabindex="-1">避免深度继承带来的复杂性 <a class="header-anchor" href="#避免深度继承带来的复杂性" aria-label="Permalink to &quot;避免深度继承带来的复杂性&quot;">​</a></h1><blockquote><p>深度继承，虽然在某些情况下可以实现代码复用，但往往会导致代码库变得难以维护和理解。让我们一起探索如何避免这种复杂性，让你的 SwiftUI 代码更清晰、更易于管理！🎉</p></blockquote><h2 id="深度继承的挑战-🤯" tabindex="-1">深度继承的挑战 🤯 <a class="header-anchor" href="#深度继承的挑战-🤯" aria-label="Permalink to &quot;深度继承的挑战 🤯&quot;">​</a></h2><p>深度继承指的是一个类继承自另一个类，而那个类又继承自另一个类，以此类推，形成一个很深的继承链。这种结构会带来以下问题：</p><ul><li><strong>代码膨胀：</strong> 子类会继承所有父类的属性和方法，即使它们并不需要。</li><li><strong>脆弱性：</strong> 修改父类的代码可能会影响到所有子类，导致意外的 bug。</li><li><strong>理解困难：</strong> 追踪代码的逻辑变得非常困难，因为你需要理解整个继承链。</li></ul><h2 id="组合优于继承-💪" tabindex="-1">组合优于继承 💪 <a class="header-anchor" href="#组合优于继承-💪" aria-label="Permalink to &quot;组合优于继承 💪&quot;">​</a></h2><p>SwiftUI 提倡“组合优于继承”的设计原则。这意味着你应该通过组合不同的视图来构建复杂的界面，而不是通过深度继承。</p><ul><li><strong>灵活性：</strong> 组合允许你灵活地选择和组合不同的组件，而无需受到继承关系的限制。</li><li><strong>可维护性：</strong> 每个组件都是独立的，修改一个组件不会影响到其他组件。</li><li><strong>可读性：</strong> 代码结构更清晰，易于理解和维护。</li></ul><h2 id="如何避免深度继承-🤔" tabindex="-1">如何避免深度继承 🤔 <a class="header-anchor" href="#如何避免深度继承-🤔" aria-label="Permalink to &quot;如何避免深度继承 🤔&quot;">​</a></h2><p>以下是一些避免深度继承的策略：</p><ol><li><p><strong>使用组合：</strong> 将复杂的视图分解成更小的、可重用的组件，然后将它们组合在一起。例如，你可以创建一个自定义的按钮视图，然后将它与其他视图组合在一起，而不是创建一个继承自 <code>Button</code> 的子类。</p></li><li><p><strong>使用协议：</strong> 定义协议来描述视图的行为，然后让不同的视图遵循这些协议。这可以让你在不使用继承的情况下实现多态性。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> configureView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CustomView </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> configureView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 配置 ViewA 的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ViewB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CustomView </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> configureView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 配置 ViewB 的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li><li><p><strong>使用修饰符：</strong> SwiftUI 的修饰符提供了一种简洁的方式来修改视图的外观和行为，而无需创建新的子类。例如，你可以使用 <code>.padding()</code> 修饰符来给视图添加内边距，而不是创建一个继承自 <code>View</code> 的子类。</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, SwiftUI!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Color.blue)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foregroundColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.white)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ol><p>通过采用这些策略，你可以避免深度继承带来的复杂性，让你的 SwiftUI 代码更清晰、更易于维护。记住，清晰的代码是良好软件的基础！🚀</p>`,12)]))}const E=i(e,[["render",p]]);export{c as __pageData,E as default};
