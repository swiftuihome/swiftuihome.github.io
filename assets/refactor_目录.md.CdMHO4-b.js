import{_ as a,c as o,o as d,ag as i}from"./chunks/framework.ymCRTBvy.js";const s=JSON.parse('{"title":"《SwiftUI封装与重构：构建可维护的UI》","description":"","frontmatter":{},"headers":[],"relativePath":"refactor/目录.md","filePath":"refactor/目录.md"}'),c={name:"refactor/目录.md"};function t(r,e,p,n,l,h){return d(),o("div",null,e[0]||(e[0]=[i('<h1 id="《swiftui封装与重构-构建可维护的ui》" tabindex="-1">《SwiftUI封装与重构：构建可维护的UI》 <a class="header-anchor" href="#《swiftui封装与重构-构建可维护的ui》" aria-label="Permalink to &quot;《SwiftUI封装与重构：构建可维护的UI》&quot;">​</a></h1><h2 id="第1章-识别并提取可复用视图" tabindex="-1">第1章 识别并提取可复用视图 <a class="header-anchor" href="#第1章-识别并提取可复用视图" aria-label="Permalink to &quot;第1章 识别并提取可复用视图&quot;">​</a></h2><p>1.1_识别重复的视图代码块</p><p>1.2_使用<code>struct</code>创建新的自定义View</p><p>1.3_将提取的视图替换回原代码</p><p>1.4_为新视图提供描述性命名</p><h2 id="第2章-通过属性传递数据" tabindex="-1">第2章 通过属性传递数据 <a class="header-anchor" href="#第2章-通过属性传递数据" aria-label="Permalink to &quot;第2章 通过属性传递数据&quot;">​</a></h2><p>2.1_为组件定义<code>let</code>常量属性</p><p>2.2_在父视图中初始化并传递数据</p><p>2.3_使用<code>@State</code>管理组件内部状态</p><p>2.4_区分何时使用<code>let</code>与<code>@State</code></p><h2 id="第3章-使用-binding实现双向数据流" tabindex="-1">第3章 使用<code>@Binding</code>实现双向数据流 <a class="header-anchor" href="#第3章-使用-binding实现双向数据流" aria-label="Permalink to &quot;第3章 使用`@Binding`实现双向数据流&quot;">​</a></h2><p>3.1_理解<code>@Binding</code>的概念与用途</p><p>3.2_在子视图中声明<code>@Binding</code>属性</p><p>3.3_在父视图中通过<code>$</code>传递绑定</p><p>3.4_实现父子视图状态的实时同步</p><h2 id="第4章-通过闭包处理组件事件" tabindex="-1">第4章 通过闭包处理组件事件 <a class="header-anchor" href="#第4章-通过闭包处理组件事件" aria-label="Permalink to &quot;第4章 通过闭包处理组件事件&quot;">​</a></h2><p>4.1_在组件中定义动作闭包属性</p><p>4.2_在组件内部的交互控件中调用闭包</p><p>4.3_父视图实现闭包以响应事件</p><p>4.4_传递无参数和带参数的闭包</p><h2 id="第5章-自定义视图修饰符-viewmodifier" tabindex="-1">第5章 自定义视图修饰符(ViewModifier) <a class="header-anchor" href="#第5章-自定义视图修饰符-viewmodifier" aria-label="Permalink to &quot;第5章 自定义视图修饰符(ViewModifier)&quot;">​</a></h2><p>5.1_创建符合<code>ViewModifier</code>协议的结构体</p><p>5.2_实现<code>body(content-)</code>方法</p><p>5.3_通过<code>modifier()</code>应用修饰符</p><p>5.4_使用<code>extension View</code>简化调用</p><h2 id="第6章-利用泛型构建通用组件" tabindex="-1">第6章 利用泛型构建通用组件 <a class="header-anchor" href="#第6章-利用泛型构建通用组件" aria-label="Permalink to &quot;第6章 利用泛型构建通用组件&quot;">​</a></h2><p>6.1_为自定义View添加泛型参数</p><p>6.2_使用<code>where</code>子句约束泛型类型</p><p>6.3_构建通用列表行或容器视图</p><p>6.4_泛型在数据展示组件中的应用</p><h2 id="第7章-使用-viewbuilder构建灵活的容器" tabindex="-1">第7章 使用<code>@ViewBuilder</code>构建灵活的容器 <a class="header-anchor" href="#第7章-使用-viewbuilder构建灵活的容器" aria-label="Permalink to &quot;第7章 使用`@ViewBuilder`构建灵活的容器&quot;">​</a></h2><p>7.1_理解<code>@ViewBuilder</code>的作用</p><p>7.2_在初始化器或函数参数中使用</p><p>7.3_创建接受多个子视图的自定义容器</p><p>7.4_实现类似<code>VStack</code>或<code>HStack</code>的组件</p><h2 id="第8章-封装环境对象-environmentobject" tabindex="-1">第8章 封装环境对象(EnvironmentObject) <a class="header-anchor" href="#第8章-封装环境对象-environmentobject" aria-label="Permalink to &quot;第8章 封装环境对象(EnvironmentObject)&quot;">​</a></h2><p>8.1_定义<code>ObservableObject</code>作为数据源</p><p>8.2_在视图层级高层注入环境对象</p><p>8.3_在子组件中使用<code>@EnvironmentObject</code>访问</p><p>8.4_环境对象在主题或账户管理中的应用</p><h2 id="第9章-识别巨型视图-massive-view" tabindex="-1">第9章 识别巨型视图(Massive View) <a class="header-anchor" href="#第9章-识别巨型视图-massive-view" aria-label="Permalink to &quot;第9章 识别巨型视图(Massive View)&quot;">​</a></h2><p>9.1_检查超过200行的<code>body</code>属性</p><p>9.2_识别嵌套层级过深的视图结构</p><p>9.3_评估视图是否承担过多职责</p><p>9.4_视图逻辑与UI描述混杂的迹象</p><h2 id="第10章-识别混乱的状态管理" tabindex="-1">第10章 识别混乱的状态管理 <a class="header-anchor" href="#第10章-识别混乱的状态管理" aria-label="Permalink to &quot;第10章 识别混乱的状态管理&quot;">​</a></h2><p>10.1_过度使用<code>@State</code>导致状态分散</p><p>10.2_不恰当的<code>@ObservedObject</code>刷新</p><p>10.3_数据源不明确（Source of Truth混乱）</p><p>10.4_<code>@Binding</code>链条过长难以追踪</p><h2 id="第11章-识别不当的逻辑放置" tabindex="-1">第11章 识别不当的逻辑放置 <a class="header-anchor" href="#第11章-识别不当的逻辑放置" aria-label="Permalink to &quot;第11章 识别不当的逻辑放置&quot;">​</a></h2><p>11.1_在<code>body</code>中执行复杂的计算或数据转换</p><p>11.2_网络请求或数据库操作直接在View中触发</p><p>11.3_业务逻辑与视图代码紧密耦合</p><p>11.4_辅助函数(Helper)滥用</p><h2 id="第12章-拆分巨型视图" tabindex="-1">第12章 拆分巨型视图 <a class="header-anchor" href="#第12章-拆分巨型视图" aria-label="Permalink to &quot;第12章 拆分巨型视图&quot;">​</a></h2><p>12.1_按功能区域拆分为子视图</p><p>12.2_按逻辑分组提取计算属性视图</p><p>12.3_使用私有方法返回<code>some View</code></p><p>12.4_应用前述的组件封装技术</p><h2 id="第13章-重构状态管理-引入mvvm" tabindex="-1">第13章 重构状态管理：引入MVVM <a class="header-anchor" href="#第13章-重构状态管理-引入mvvm" aria-label="Permalink to &quot;第13章 重构状态管理：引入MVVM&quot;">​</a></h2><p>13.1_创建<code>ViewModel</code>作为<code>ObservableObject</code></p><p>13.2_将业务逻辑和状态从View迁移到ViewModel</p><p>13.3_在View中使用<code>@StateObject</code>或<code>@ObservedObject</code></p><p>13.4_通过函数和<code>@Published</code>属性进行交互</p><h2 id="第14章-优化数据流和依赖" tabindex="-1">第14章 优化数据流和依赖 <a class="header-anchor" href="#第14章-优化数据流和依赖" aria-label="Permalink to &quot;第14章 优化数据流和依赖&quot;">​</a></h2><p>14.1_使用<code>@EnvironmentObject</code>共享全局状态</p><p>14.2_将多个<code>@State</code>属性合并到单一结构体中</p><p>14.3_利用<code>Combine</code>处理复杂的数据流</p><p>14.4_通过服务层(Service Layer)抽象数据获取</p><h2 id="第15章-精炼视图逻辑" tabindex="-1">第15章 精炼视图逻辑 <a class="header-anchor" href="#第15章-精炼视图逻辑" aria-label="Permalink to &quot;第15章 精炼视图逻辑&quot;">​</a></h2><p>15.1_将<code>if-else</code>或<code>switch</code>逻辑移入ViewModel</p><p>15.2_创建专门的格式化工具(Formatter)</p><p>15.3_使用<code>extension</code>为数据模型添加计算属性</p><p>15.4_将重复的UI配置封装到<code>ViewModifier</code>中</p>',76)]))}const b=a(c,[["render",t]]);export{s as __pageData,b as default};
