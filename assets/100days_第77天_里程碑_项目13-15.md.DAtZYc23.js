import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.Bw-5EFTY.js";const c=JSON.parse('{"title":"第77天 里程碑 项目 13-15","description":"","frontmatter":{},"headers":[],"relativePath":"100days/第77天_里程碑_项目13-15.md","filePath":"100days/第77天_里程碑_项目13-15.md"}'),p={name:"100days/第77天_里程碑_项目13-15.md"};function e(h,s,t,k,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="第77天-里程碑-项目-13-15" tabindex="-1">第77天 里程碑 项目 13-15 <a class="header-anchor" href="#第77天-里程碑-项目-13-15" aria-label="Permalink to &quot;第77天 里程碑 项目 13-15&quot;">​</a></h1><p>你已经完成了两个有难度的项目和一个技术项目，现在你对SwiftUI的掌握应该已经相当全面了——我真心希望你已经开始体会到，它比苹果之前的框架要简单得多！</p><p>今天是时候停下来回顾一下一下所学内容了。我们还会深入探讨两个主题——运算符重载和属性包装器，因为通过深入学习这两个主题，你能更深刻地理解我们一直在使用的功能。此外，今天还有一个挑战任务，你需要运用所学技能构建一个全新的应用程序。</p><p>挑战能让你以实践的方式检验自己的学习成果，为你提供一个可以充分展现自我的“沙盒”，如果你愿意，还能借此机会突破自我。我也希望这些挑战能让你看到，只要用心去做，你就能做到多么出色。正如西塞莉·泰森所说：“挑战能让你发现自己从未未曾了解的一面”，希望今天你能发现自己已经取得了多么大的进步！</p><p><strong>今天你需要学习三个主题，其中一个是挑战任务。</strong></p><ul><li>所学内容</li><li>重点要点</li><li>挑战任务</li></ul><p><strong>注意：</strong> 如果当天没有完成挑战也不用担心——在之后的学习中，你会发现时不时会有一些空闲时间，所以挑战任务可以留到以后再完成。</p><h2 id="所学内容" tabindex="-1">所学内容 <a class="header-anchor" href="#所学内容" aria-label="Permalink to &quot;所学内容&quot;">​</a></h2><p>这些项目开始带你接触SwiftUI中较难的部分，但这些难点其实并非SwiftUI本身的问题——而是当SwiftUI与苹果旧框架交互时，事情才会变得有些复杂。随着时间的推移，这些“粗糙的边缘”会逐渐得到改善，但这可能需要几年时间。无论如何，当你需要集成来自苹果生态之外的代码时，这些知识仍然非常重要。</p><p>在完成这三个项目的过程中，你还学到了以下内容：</p><ul><li>属性包装器如何转化为结构体</li><li>显示带有多个按钮的确认对话框</li><li>使用Core Image处理图像</li><li>在SwiftUI中导入照片</li><li>在SwiftUI中集成地图</li><li>在地图上添加图钉</li><li>从应用程序中分享内容</li><li>为自定义类型添加Comparable协议一致性</li><li>找到并写入用户的文档目录</li><li>写入文件时启用文件加密</li><li>使用Touch ID和Face ID对用户进行身份验证</li></ul><p>这些主题都先以独立技术点的形式讲解，然后在实际项目中应用，希望你能真正理解并掌握这些内容！</p><h2 id="重点要点" tabindex="-1">重点要点 <a class="header-anchor" href="#重点要点" aria-label="Permalink to &quot;重点要点&quot;">​</a></h2><p>今天我想深入探讨两个主题，这两个主题都颇具一定难度，但我相信它们能帮助你更深入地理解前三个项目中涉及的内容。</p><h2 id="运算符重载" tabindex="-1">运算符重载 <a class="header-anchor" href="#运算符重载" aria-label="Permalink to &quot;运算符重载&quot;">​</a></h2><p>当我们为自定义类型添加Comparable协议一致性时，需要实现一个名为<code>&lt;</code>的方法。这个方法能让Swift比较<code>a &lt; b</code>这类表达式，从而让我们可以使用无需参数的<code>sorted()</code>方法。</p><p>这就是所谓的“运算符重载”，正是因为有了它，我们才能用同一个<code>+</code>运算符实现两个整数的相加或两个字符串的拼接。你可以自定义运算符，也可以轻松扩展现现有运算符的功能，让它们实现新的操作。</p><p>举个例子，我们可以为<code>Int</code>添加一些扩展，实现<code>Int</code>与<code>Double</code>的乘法运算——Swift默认不支持这种操作，这有时会带来不便：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extension</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rhs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>请特别注意参数：该方法的左操作数是<code>Int</code>类型，右操作数是<code>Double</code>类型，这意味着如果交换两个操作数的位置，该方法将无法生效。因此，如果你想让两种顺序的运算都能生效，就需要定义两个这样的方法。</p><p>不过，如果你想做到“完全兼容”，那么扩展<code>Int</code>并不是最佳选择：我们应该向上扩展到一个既能包含<code>Int</code>，又能包含其他整数类型（比如我们在Core Data中使用的<code>Int16</code>）的协议。Swift将所有整数类型都归到了<code>BinaryInteger</code>这个协议中。如果我们为这个协议编写扩展，那么<code>Self</code>（首字母大写）就代表具体使用的类型。也就是说，当用于<code>Int</code>类型时，<code>Self</code>表示<code>Int</code>；当用于<code>Int16</code>类型时，<code>Self</code>就表示<code>Int16</code>。</p><p>下面这个扩展实现了任意任意整数类型与<code>Double</code>的乘法运算，无论整数在左侧还是右侧：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extension</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BinaryInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rhs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lhs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rhs)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>你可能会问，为什么Swift不默认启用这些运算符？原因是这种运算的精度无法保证达到预期。举个简单的例子，试试下面的代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exampleInt: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50_000_000_000_000_001</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(exampleInt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exampleInt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;%.0f&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, result))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这段代码创建了一个64位整数，值为50万亿零1。然后通过我们自定义的扩展将其与<code>Double</code>类型的1.0相乘，理论上结果应该与原整数相同。但<code>String(format:_:)</code>方法要求不保留小数位输出，此时你会发现结果与原整数并不一致：结果是50万亿，少了末尾的1。你可能会问“对于50万亿来说，1又算得了什么”，这没问题——我并不是要评判对错，只是想告诉你，如果你需要绝对的精度，就应该避免使用这类辅助方法。</p><p>更广泛地说，我想给你一个关于运算符重载的提醒。在第14个项目中介绍运算符重载时，我说过它“既是福音福也是祸”，现在我想简要说明一下原因。</p><p>看看下面这段代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> paul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> swift </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Language</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> paul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> swift</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>result</code>是什么类型的数据呢？我能想到几种可能性：</p><ol><li>可能是另一个<code>User</code>对象，只不过该对象已被修改，其已知语言数组中包含了Swift。</li><li>可能是一个结合了用户和语言信息的<code>Programmer</code>对象。</li><li>可能是经典经典恐怖电影《变蝇人》的奇怪翻拍（此处为调侃，无实际意义）。</li></ol><p>关键在于，我们无法直接判断<code>result</code>的类型，必须阅读相关<code>+</code>运算符的源代码才能知晓。</p><p>再看看下面这段代码：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> paul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> swift </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Language</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">paul.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">learn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(swift)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我认为这段段代码要清晰得多：我们在一个对象上调用了一个简单的方法，你很可能会猜到，这段代码的作用是修改<code>paul</code>的属性，将Swift添加到其编程语言数组中。</p><p>任何优秀的开发者都会告诉你，清晰度是编写优质代码的重要特质之一——我们需要让代码清晰地表达出我们的意图，因为这些代码在未来会被阅读数十次甚至数百次。</p><p>因此，你当然可以将运算符重载纳入自己的技能库，用它来解决问题（事实上，我在我的著作《Pro Swift》中对运算符重载有更详细的讲解，链接：<a href="https://www.hackingwithswift.com/store/pro-swift%EF%BC%89%EF%BC%8C%E4%BD%86%E4%BD%BF%E7%94%A8%E6%97%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E8%B0%A8%E6%85%8E%E3%80%82" target="_blank" rel="noreferrer">https://www.hackingwithswift.com/store/pro-swift），但使用时一定要谨慎。</a></p><h2 id="自定义属性包装器" tabindex="-1">自定义属性包装器 <a class="header-anchor" href="#自定义属性包装器" aria-label="Permalink to &quot;自定义属性包装器&quot;">​</a></h2><p>你已经了解到，属性包装器本质上是一种“障眼法”：它将一个简单的值包装在另一个值中，以便添加额外的功能。比如SwiftUI用<code>@State</code>在其他位置存储值，或者用<code>@Environment</code>从共享数据源中读取值，原理都是如此——给一个简单的值赋予某种“超能力”。</p><p>我们可以在自己的代码中使用属性包装器，而且有很多使用它的理由。和运算符重载一样，尝试使用属性包装器能让你更深入地理解其工作原理，但使用时也需要深思熟虑：如果一遇到问题就想到用属性包装器，那你很可能犯了错。</p><p>为了演示属性包装器，我们先创建一个简单的结构体，用于包装某种种<code>BinaryInteger</code>类型的值。我们会为这个结构体设置自定义代码来处理其包装值：如果新值小于0，就将其设为0，确保这个结构体的值永远不会是负数。</p><p>代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonNegative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BinaryInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Value</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wrappedValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wrappedValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wrappedValue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wrappedValue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>现在我们可以用一个整数来创建这个结构体，但如果这个整数小于0，它会被限制为0。因此，下面的代码会输出0：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> example </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NonNegative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">wrappedValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">example.wrappedValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(example.wrappedValue)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>属性包装器的作用是，让我们可以在结构体或类的任意属性上使用这种包装逻辑。更方便的是，只需一步操作：在<code>NonNegative</code>结构体前加上<code>@propertyWrapper</code>，代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@propertyWrapper</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonNegative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BinaryInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样就可以了——我们已经创建了自己的属性包装器！</p><p>想必你已经从名称中猜到，属性包装器只能只能只能用于“属性”，而不能用于普通的变量或常量。因此，为了测试我们创建的属性包装器，我们将它放在<code>User</code>结构体中，代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    @NonNegative</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>现在我们可以创建一个用户对象，随意增减分数，并且完全不用担心分数会变成负数：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.score)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.score)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>由此可见，这其中并没有什么“魔法”：属性包装器只是过是一种语法糖，让一个数据被另一个数据包装起来，而且我们也可以根据需要自行创建属性包装器。</p><h2 id="挑战任务" tabindex="-1">挑战任务 <a class="header-anchor" href="#挑战任务" aria-label="Permalink to &quot;挑战任务&quot;">​</a></h2><p>你是否有过这样的经历：在会议或聚会中，和陌生人聊了一会儿，走开后几秒钟就忘了对方的名字？不止你一个人有这种情况，而你今天要构建的应用程序就能能解决这类问题。</p><p>你的目标是构建一个应用程序，让用户从照片库中导入一张图片，然后为导入的内容添加名称。应用程序需要在列表中显示所有已命名的图片，点击列表中的项目时，会跳转到详情细页面，展示该图片的放大版本。</p><p>具体分解解任务如下：</p><ul><li>使用<code>PhotosPicker</code>让用户从照片库中导入照片。</li><li>检测到新照片导入后，立即提示用户为照片命名。</li><li>将名称和照片妥善保存。</li><li>在列表中显示所有名称和照片，并按名称排序。</li><li>创建详情页面，以全屏形式展示图片。</li><li>确定保存所有数据的方式。</li></ul><p>记住，要将用户导入的照片以<code>Data</code>（数据）形式存储，这样便于写入文件。</p><p>你可以选择使用SwiftData来完成这个项目，但这并非必需——将数据写入文档目录中的JSON文件也可以。不过，要实现数组排序，你需要为相关类型添加自定义的Comparable协议一致性。</p><p>如果你确实选择使用SwiftData，这里有一个重要提示：当在模型中存储图片或视频等大型数据时，需要使用特殊的<code>@Attribute</code>宏来定义相关属性，代码如下：</p><div class="language-swift vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.externalStorage) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> photo: Data</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这会告诉SwiftData不要将图片数据直接保存在数据库中，而是将其存储在数据库旁边——这种方式效率高得多。</p><p>记住，你已经掌握了完成这个项目所需的全部知识——祝你好运！</p>`,64)]))}const g=i(p,[["render",e]]);export{c as __pageData,g as default};
